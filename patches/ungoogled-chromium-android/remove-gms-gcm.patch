Remove dependency on com.google.android.gms.gcm (play-services-gcm-15.0.1.aar).
It also disalbes Snippets, auto-update of offline pages and launching browser from background service.
The snippets are already disabled in native codes, this will disable it on Java level.
author: Wengling Chen <feiyu2817@gmail.com>

---
 chrome/android/BUILD.gn                            |   3 -
 chrome/android/java/AndroidManifest.xml            |  60 --------
 .../chrome/browser/BackgroundSyncLauncher.java     |  64 +-------
 .../chrome/browser/ChromeBackgroundService.java    |  96 +-----------
 .../invalidation/InvalidationController.java       |   8 +-
 .../browser/ntp/snippets/SnippetsLauncher.java     |  59 +-------
 .../services/gcm/ChromeGcmListenerService.java     |  58 +-------
 components/background_task_scheduler/BUILD.gn      |   3 -
 .../BackgroundTaskGcmTaskService.java              |  53 +------
 .../BackgroundTaskSchedulerFactory.java            |   6 +-
 .../BackgroundTaskSchedulerGcmNetworkManager.java  | 164 +--------------------
 third_party/android_deps/BUILD.gn                  |  15 --
 third_party/cacheinvalidation/BUILD.gn             |   1 -
 .../client/android2/AndroidManifestUpdatedGcm.xml  |  20 ---
 .../android2/channel/AndroidGcmController.java     |  42 +-----
 .../channel/AndroidInstanceIDListenerService.java  |  13 +-
 .../channel/GcmRegistrationTaskService.java        |  89 +----------
 17 files changed, 21 insertions(+), 733 deletions(-)

diff --git a/chrome/android/BUILD.gn b/chrome/android/BUILD.gn
--- a/chrome/android/BUILD.gn
+++ b/chrome/android/BUILD.gn
@@ -269,7 +269,6 @@ android_library("chrome_java") {
     "$google_play_services_package:google_play_services_cast_framework_java",
     "$google_play_services_package:google_play_services_cast_java",
     "$google_play_services_package:google_play_services_fido_java",
-    "$google_play_services_package:google_play_services_gcm_java",
     "$google_play_services_package:google_play_services_iid_java",
     "$google_play_services_package:google_play_services_tasks_java",
     "//base:base_java",
@@ -742,7 +741,6 @@ android_library("chrome_test_java") {
     "$google_play_services_package:google_play_services_cast_framework_java",
     "$google_play_services_package:google_play_services_cast_java",
     "$google_play_services_package:google_play_services_fido_java",
-    "$google_play_services_package:google_play_services_gcm_java",
     "$google_play_services_package:google_play_services_iid_java",
     "$google_play_services_package:google_play_services_tasks_java",
     "//base:base_java",
@@ -1582,7 +1580,6 @@ android_library("browser_java_test_support") {
   ]
   deps = [
     ":chrome_java",
-    "$google_play_services_package:google_play_services_gcm_java",
     "//base:base_java",
     "//base:base_java_test_support",
     "//chrome/android/public/profiles:java",
diff --git a/chrome/android/java/AndroidManifest.xml b/chrome/android/java/AndroidManifest.xml
--- a/chrome/android/java/AndroidManifest.xml
+++ b/chrome/android/java/AndroidManifest.xml
@@ -83,22 +83,17 @@ by a child template that "extends" this file.
     <permission android:name="{{ manifest_package }}.permission.CHILD_SERVICE" android:protectionLevel="signature" />
     <permission android:name="{{ manifest_package }}.permission.READ_WRITE_BOOKMARK_FOLDERS" android:protectionLevel="signatureOrSystem" />
     <permission android:name="{{ manifest_package }}.TOS_ACKED" android:protectionLevel="signatureOrSystem" />
-    <!-- Only chrome can receive the messages and registration result -->
-    <permission android:name="{{ manifest_package }}.permission.C2D_MESSAGE"
-        android:protectionLevel="signature" />
     <permission android:name="{{ manifest_package }}.permission.DEBUG"
                 android:label="Debug web pages"
                 android:permissionGroup="android.permission-group.DEVELOPMENT_TOOLS"
                 android:protectionLevel="signature" />
 
-    <uses-permission android:name="{{ manifest_package }}.permission.C2D_MESSAGE" />
     <uses-permission android:name="{{ manifest_package }}.permission.READ_WRITE_BOOKMARK_FOLDERS" />
     <uses-permission android:name="{{ manifest_package }}.TOS_ACKED" />
 
     <uses-permission android:name="com.chrome.permission.DEVICE_EXTRAS" />
     <uses-permission android:name="com.android.browser.permission.READ_HISTORY_BOOKMARKS"/>
     <uses-permission android:name="com.android.browser.permission.WRITE_HISTORY_BOOKMARKS"/>
-    <uses-permission android:name="com.google.android.c2dm.permission.RECEIVE" />
     <uses-permission android:name="com.android.launcher.permission.INSTALL_SHORTCUT"/>
 
     <uses-permission android:name="com.google.android.apps.now.CURRENT_ACCOUNT_ACCESS" />
@@ -1058,43 +1053,6 @@ by a child template that "extends" this file.
             android:configChanges="orientation|keyboardHidden|keyboard|screenSize|mcc|mnc|screenLayout|smallestScreenSize"
             android:hardwareAccelerated="false" />
 
-        <!-- Receiver for GCM messages. -->
-        <receiver android:name="com.google.android.gms.gcm.GcmReceiver"
-            android:exported="true"
-            android:permission="com.google.android.c2dm.permission.SEND">
-            <intent-filter>
-                <action android:name="com.google.android.c2dm.intent.RECEIVE" />
-                <action android:name="com.google.android.c2dm.intent.REGISTRATION" />
-               <category android:name="{{ manifest_package }}"/>
-            </intent-filter>
-        </receiver>
-        <!-- GcmTaskService for registration for Invalidations. -->
-        <service android:name="com.google.ipc.invalidation.ticl.android2.channel.GcmRegistrationTaskService"
-            android:exported="true"
-            android:permission="com.google.android.gms.permission.BIND_NETWORK_TASK_SERVICE" >
-            <intent-filter>
-                <action android:name="com.google.android.gms.gcm.ACTION_TASK_READY"/>
-            </intent-filter>
-        </service>
-        <!-- InstanceIDListenerService for token refresh events from GCM. -->
-        <service android:name="com.google.ipc.invalidation.ticl.android2.channel.AndroidInstanceIDListenerService"
-            android:exported="false">
-            <intent-filter>
-                <action android:name="com.google.android.gms.iid.InstanceID"/>
-            </intent-filter>
-        </service>
-        <!-- GcmListenerService for messages from GCM. -->
-        <service android:name="org.chromium.chrome.browser.services.gcm.ChromeGcmListenerService"
-            android:exported="false" >
-            <intent-filter>
-              <action android:name="com.google.android.c2dm.intent.RECEIVE" />
-            </intent-filter>
-        </service>
-        <meta-data android:name="ipc.invalidation.ticl.gcm_upstream_service_class"
-            android:value="org.chromium.chrome.browser.services.gcm.InvalidationGcmUpstreamSender" />
-        <service android:name="org.chromium.chrome.browser.services.gcm.InvalidationGcmUpstreamSender"
-            android:exported="false"/>
-
         <!-- Notification service for sync. -->
         <meta-data android:name="ipc.invalidation.ticl.listener_service_class"
             android:value="org.chromium.chrome.browser.invalidation.ChromeInvalidationClientService"/>
@@ -1134,24 +1092,6 @@ by a child template that "extends" this file.
             android:exported="false"
             android:permission="android.permission.BIND_JOB_SERVICE"/>
 
-        <!-- Background Task Scheduler GCM task service -->
-        <service android:name="org.chromium.components.background_task_scheduler.BackgroundTaskGcmTaskService"
-            android:permission="com.google.android.gms.permission.BIND_NETWORK_TASK_SERVICE"
-            android:exported="true">
-            <intent-filter>
-                <action android:name="com.google.android.gms.gcm.ACTION_TASK_READY" />
-            </intent-filter>
-        </service>
-
-        <!-- GcmTaskService implementation to wake Chrome on scheduled events -->
-        <service android:name="org.chromium.chrome.browser.ChromeBackgroundService"
-            android:permission="com.google.android.gms.permission.BIND_NETWORK_TASK_SERVICE"
-            android:exported="true">
-            <intent-filter>
-                <action android:name="com.google.android.gms.gcm.ACTION_TASK_READY" />
-            </intent-filter>
-        </service>
-
         <service android:name="org.chromium.chrome.browser.prerender.ChromePrerenderService"
             android:exported="true"
             tools:ignore="ExportedService" />
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/BackgroundSyncLauncher.java b/chrome/android/java/src/org/chromium/chrome/browser/BackgroundSyncLauncher.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/BackgroundSyncLauncher.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/BackgroundSyncLauncher.java
@@ -8,10 +8,6 @@ import android.content.Context;
 import android.content.SharedPreferences;
 import android.os.StrictMode;
 
-import com.google.android.gms.gcm.GcmNetworkManager;
-import com.google.android.gms.gcm.OneoffTask;
-import com.google.android.gms.gcm.Task;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.base.Log;
 import org.chromium.base.VisibleForTesting;
@@ -37,8 +33,6 @@ public class BackgroundSyncLauncher {
     // BackgroundSyncLauncherAndroid, if any. If it is non-null then the browser is running.
     private static BackgroundSyncLauncher sInstance;
 
-    private GcmNetworkManager mScheduler;
-
     /**
      * Disables the automatic use of the GCMNetworkManager. When disabled, the methods which
      * interact with GCM can still be used, but will not be called automatically on creation, or by
@@ -47,7 +41,7 @@ public class BackgroundSyncLauncher {
      * Automatic GCM use is disabled by tests, and also by this class if it is determined on
      * creation that the installed Play Services library is out of date.
      */
-    private static boolean sGCMEnabled = true;
+    private static boolean sGCMEnabled;
 
     @VisibleForTesting
     protected AsyncTask<Void> mLaunchBrowserIfStoppedTask;
@@ -135,15 +129,6 @@ public class BackgroundSyncLauncher {
             @Override
             protected void onPostExecute(Void params) {
                 if (sGCMEnabled) {
-                    if (shouldLaunch) {
-                        RecordHistogram.recordBooleanHistogram(
-                                "BackgroundSync.LaunchTask.ScheduleSuccess",
-                                scheduleLaunchTask(mScheduler, minDelayMs));
-                    } else {
-                        RecordHistogram.recordBooleanHistogram(
-                                "BackgroundSync.LaunchTask.CancelSuccess",
-                                removeScheduledTasks(mScheduler));
-                    }
                 }
             }
         }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
@@ -158,7 +143,7 @@ public class BackgroundSyncLauncher {
     }
 
     protected BackgroundSyncLauncher() {
-        mScheduler = GcmNetworkManager.getInstance(ContextUtils.getApplicationContext());
+        sGCMEnabled = false;
         launchBrowserIfStopped(false, 0);
     }
 
@@ -187,49 +172,6 @@ public class BackgroundSyncLauncher {
         return !sGCMEnabled;
     }
 
-    private static boolean scheduleLaunchTask(GcmNetworkManager scheduler, long minDelayMs) {
-        // Google Play Services may not be up to date, if the application was not installed through
-        // the Play Store. In this case, scheduling the task will fail silently.
-        final long minDelaySecs = minDelayMs / 1000;
-        OneoffTask oneoff = new OneoffTask.Builder()
-                                    .setService(ChromeBackgroundService.class)
-                                    .setTag(TASK_TAG)
-                                    // We have to set a non-zero execution window here
-                                    .setExecutionWindow(minDelaySecs, minDelaySecs + 1)
-                                    .setRequiredNetwork(Task.NETWORK_STATE_CONNECTED)
-                                    .setPersisted(true)
-                                    .setUpdateCurrent(true)
-                                    .build();
-        try {
-            scheduler.schedule(oneoff);
-        } catch (IllegalArgumentException e) {
-            // Disable GCM for the remainder of this session.
-            setGCMEnabled(false);
-            // Return false so that the failure will be logged.
-            return false;
-        }
-        return true;
-    }
-
-    private static boolean removeScheduledTasks(GcmNetworkManager scheduler) {
-        // Third-party code causes broadcast to touch disk. http://crbug.com/614679
-        StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
-        try {
-            scheduler.cancelTask(TASK_TAG, ChromeBackgroundService.class);
-        } catch (IllegalArgumentException e) {
-            // This occurs when BackgroundSyncLauncherService is not found in the application
-            // manifest. This should not happen in code that reaches here, but has been seen in
-            // the past. See https://crbug.com/548314
-            // Disable GCM for the remainder of this session.
-            setGCMEnabled(false);
-            // Return false so that the failure will be logged.
-            return false;
-        } finally {
-            StrictMode.setThreadPolicy(oldPolicy);
-        }
-        return true;
-    }
-
     /**
      * Reschedule any required background sync tasks, if they have been removed due to an
      * application upgrade.
@@ -240,14 +182,12 @@ public class BackgroundSyncLauncher {
      * BackgroundSyncLauncher.
      */
     protected static void rescheduleTasksOnUpgrade(final Context context) {
-        final GcmNetworkManager scheduler = GcmNetworkManager.getInstance(context);
         BackgroundSyncLauncher.ShouldLaunchCallback callback = shouldLaunch -> {
             if (shouldLaunch) {
                 // It's unclear what time the sync event was supposed to fire, so fire
                 // without delay and let the browser reschedule if necessary.
                 // TODO(iclelland): If this fails, report the failure via UMA (not now,
                 // since the browser is not running, but on next startup.)
-                scheduleLaunchTask(scheduler, 0);
             }
         };
         BackgroundSyncLauncher.shouldLaunchBrowserIfStopped(callback);
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/ChromeBackgroundService.java b/chrome/android/java/src/org/chromium/chrome/browser/ChromeBackgroundService.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/ChromeBackgroundService.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/ChromeBackgroundService.java
@@ -6,10 +6,6 @@ package org.chromium.chrome.browser;
 
 import android.content.Context;
 
-import com.google.android.gms.gcm.GcmNetworkManager;
-import com.google.android.gms.gcm.GcmTaskService;
-import com.google.android.gms.gcm.TaskParams;
-
 import org.chromium.base.Log;
 import org.chromium.base.VisibleForTesting;
 import org.chromium.base.library_loader.ProcessInitException;
@@ -27,67 +23,9 @@ import org.chromium.content_public.browser.UiThreadTaskTraits;
  * browser needs to be launched for scheduled tasks, or in response to changing network or power
  * conditions.
  */
-public class ChromeBackgroundService extends GcmTaskService {
+public class ChromeBackgroundService {
     private static final String TAG = "BackgroundService";
 
-    @Override
-    @VisibleForTesting
-    public int onRunTask(final TaskParams params) {
-        final String taskTag = params.getTag();
-        final Context context = this;
-        PostTask.runOrPostTask(UiThreadTaskTraits.DEFAULT, () -> {
-            switch (taskTag) {
-                case BackgroundSyncLauncher.TASK_TAG:
-                    handleBackgroundSyncEvent(context, taskTag);
-                    break;
-
-                case OfflinePageUtils.TASK_TAG:
-                    // Offline pages are migrating to BackgroundTaskScheduler, therefore getting
-                    // a task through ChromeBackgroundSerivce should cause a rescheduling using
-                    // the new component.
-                    rescheduleOfflinePages();
-                    break;
-
-                case SnippetsLauncher.TASK_TAG_WIFI:
-                case SnippetsLauncher.TASK_TAG_FALLBACK:
-                    handleSnippetsOnPersistentSchedulerWakeUp(context, taskTag);
-                    break;
-
-                // This is only for tests.
-                case ServiceManagerStartupUtils.TASK_TAG:
-                    handleServicificationStartupTask(context, taskTag);
-                    break;
-
-                default:
-                    Log.i(TAG, "Unknown task tag " + taskTag);
-                    break;
-            }
-        });
-
-        return GcmNetworkManager.RESULT_SUCCESS;
-    }
-
-    private void handleBackgroundSyncEvent(Context context, String tag) {
-        if (!BackgroundSyncLauncher.hasInstance()) {
-            // Start the browser. The browser's BackgroundSyncManager (for the active profile) will
-            // start, check the network, and run any necessary sync events. This task runs with a
-            // wake lock, but has a three minute timeout, so we need to start the browser in its
-            // own task.
-            // TODO(jkarlin): Protect the browser sync event with a wake lock.
-            // See crbug.com/486020.
-            launchBrowser(context, tag);
-        }
-    }
-
-    private void handleSnippetsOnPersistentSchedulerWakeUp(Context context, String tag) {
-        if (!SnippetsLauncher.hasInstance()) launchBrowser(context, tag);
-        snippetsOnPersistentSchedulerWakeUp();
-    }
-
-    private void handleServicificationStartupTask(Context context, String tag) {
-        launchBrowser(context, tag);
-    }
-
     @VisibleForTesting
     protected void snippetsOnPersistentSchedulerWakeUp() {
         SnippetsBridge.onPersistentSchedulerWakeUp();
@@ -98,41 +36,9 @@ public class ChromeBackgroundService extends GcmTaskService {
         SnippetsBridge.onBrowserUpgraded();
     }
 
-    @VisibleForTesting
-    protected void launchBrowser(Context context, String tag) {
-        Log.i(TAG, "Launching browser");
-        try {
-            ChromeBrowserInitializer.getInstance(this).handleSynchronousStartup();
-        } catch (ProcessInitException e) {
-            Log.e(TAG, "ProcessInitException while starting the browser process");
-            // Since the library failed to initialize nothing in the application
-            // can work, so kill the whole application not just the activity.
-            System.exit(-1);
-        }
-    }
-
-    @VisibleForTesting
-    protected void rescheduleBackgroundSyncTasksOnUpgrade() {
-        BackgroundSyncLauncher.rescheduleTasksOnUpgrade(this);
-    }
-
-    private void handleSnippetsOnBrowserUpgraded() {
-        if (SnippetsLauncher.shouldNotifyOnBrowserUpgraded()) {
-            if (!SnippetsLauncher.hasInstance()) {
-                launchBrowser(this, /*tag=*/""); // The |tag| doesn't matter here.
-            }
-            snippetsOnBrowserUpgraded();
-        }
-    }
-
     /** Reschedules offline pages (using appropriate version of Background Task Scheduler). */
     protected void rescheduleOfflinePages() {
         BackgroundScheduler.getInstance().reschedule();
     }
 
-    @Override
-    public void onInitializeTasks() {
-        rescheduleBackgroundSyncTasksOnUpgrade();
-        handleSnippetsOnBrowserUpgraded();
-    }
 }
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/invalidation/InvalidationController.java b/chrome/android/java/src/org/chromium/chrome/browser/invalidation/InvalidationController.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/invalidation/InvalidationController.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/invalidation/InvalidationController.java
@@ -169,6 +169,7 @@ public class InvalidationController implements ApplicationStatus.ApplicationStat
 
         // Ensure GCM has been initialized.
         ensureGcmIsInitialized();
+        if (!mGcmInitialized) return;
 
         // Do not apply changes to {@link #mSessionInvalidationsEnabled} yet because the timer task
         // may be scheduled far into the future.
@@ -194,12 +195,7 @@ public class InvalidationController implements ApplicationStatus.ApplicationStat
      */
     private void ensureGcmIsInitialized() {
         if (mGcmInitialized) return;
-        mGcmInitialized = true;
-        PostTask.postTask(TaskTraits.BEST_EFFORT_MAY_BLOCK, () -> {
-            boolean useGcmUpstream = true;
-            AndroidGcmController.get(ContextUtils.getApplicationContext())
-                    .initializeGcm(useGcmUpstream);
-        });
+        mGcmInitialized = false;
     }
 
     @VisibleForTesting
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/ntp/snippets/SnippetsLauncher.java b/chrome/android/java/src/org/chromium/chrome/browser/ntp/snippets/SnippetsLauncher.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/ntp/snippets/SnippetsLauncher.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/ntp/snippets/SnippetsLauncher.java
@@ -7,15 +7,10 @@ package org.chromium.chrome.browser.ntp.snippets;
 import android.content.Context;
 import android.net.ConnectivityManager;
 
-import com.google.android.gms.gcm.GcmNetworkManager;
-import com.google.android.gms.gcm.PeriodicTask;
-import com.google.android.gms.gcm.Task;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.base.Log;
 import org.chromium.base.VisibleForTesting;
 import org.chromium.base.annotations.CalledByNative;
-import org.chromium.chrome.browser.ChromeBackgroundService;
 import org.chromium.chrome.browser.externalauth.ExternalAuthUtils;
 
 /**
@@ -40,9 +35,7 @@ public class SnippetsLauncher {
     // If it is non-null then the browser is running.
     private static SnippetsLauncher sInstance;
 
-    private GcmNetworkManager mScheduler;
-
-    private boolean mGCMEnabled = true;
+    private boolean mGCMEnabled;
 
     /**
      * Create a SnippetsLauncher object, which is owned by C++.
@@ -77,8 +70,8 @@ public class SnippetsLauncher {
     }
 
     protected SnippetsLauncher() {
+        mGCMEnabled = false;
         checkGCM();
-        mScheduler = GcmNetworkManager.getInstance(ContextUtils.getApplicationContext());
     }
 
     private void checkGCM() {
@@ -89,34 +82,6 @@ public class SnippetsLauncher {
         }
     }
 
-    private static PeriodicTask buildFetchTask(
-            String tag, long periodSeconds, int requiredNetwork) {
-        // Add a bit of "flex" around the target period. This achieves the following:
-        // - It makes sure the task doesn't run (significantly) before its initial period has
-        //   elapsed. In practice, the scheduler seems to behave like that anyway, but it doesn't
-        //   guarantee that, so we shouldn't rely on it.
-        // - It gives the scheduler a bit of room to optimize for battery life.
-        long effectivePeriodSeconds = (long) (periodSeconds * (1.0 + FLEX_FACTOR));
-        long flexSeconds = (long) (periodSeconds * (2.0 * FLEX_FACTOR));
-        return new PeriodicTask.Builder()
-                .setService(ChromeBackgroundService.class)
-                .setTag(tag)
-                .setPeriod(effectivePeriodSeconds)
-                .setFlex(flexSeconds)
-                .setRequiredNetwork(requiredNetwork)
-                .setPersisted(true)
-                .setUpdateCurrent(true)
-                .build();
-    }
-
-    private void scheduleOrCancelFetchTask(String taskTag, long period, int requiredNetwork) {
-        if (period > 0) {
-            mScheduler.schedule(buildFetchTask(taskTag, period, requiredNetwork));
-        } else {
-            mScheduler.cancelTask(taskTag, ChromeBackgroundService.class);
-        }
-    }
-
     @CalledByNative
     private boolean schedule(long periodWifiSeconds, long periodFallbackSeconds) {
         if (!mGCMEnabled) return false;
@@ -128,22 +93,12 @@ public class SnippetsLauncher {
                 .putBoolean(PREF_IS_SCHEDULED, isScheduled)
                 .apply();
 
-        // Google Play Services may not be up to date, if the application was not installed through
-        // the Play Store. In this case, scheduling the task will fail silently.
-        try {
-            scheduleOrCancelFetchTask(
-                    TASK_TAG_WIFI, periodWifiSeconds, Task.NETWORK_STATE_UNMETERED);
-            scheduleOrCancelFetchTask(
-                    TASK_TAG_FALLBACK, periodFallbackSeconds, Task.NETWORK_STATE_CONNECTED);
-        } catch (IllegalArgumentException e) {
-            // Disable GCM for the remainder of this session.
-            mGCMEnabled = false;
+        // Disable GCM for the remainder of this session.
+        mGCMEnabled = false;
 
-            ContextUtils.getAppSharedPreferences().edit().remove(PREF_IS_SCHEDULED).apply();
-            // Return false so that the failure will be logged.
-            return false;
-        }
-        return true;
+        ContextUtils.getAppSharedPreferences().edit().remove(PREF_IS_SCHEDULED).apply();
+        // Return false so that the failure will be logged.
+        return false;
     }
 
     @CalledByNative
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/services/gcm/ChromeGcmListenerService.java b/chrome/android/java/src/org/chromium/chrome/browser/services/gcm/ChromeGcmListenerService.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/services/gcm/ChromeGcmListenerService.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/services/gcm/ChromeGcmListenerService.java
@@ -10,7 +10,6 @@ import android.os.Bundle;
 import android.os.SystemClock;
 import android.text.TextUtils;
 
-import com.google.android.gms.gcm.GcmListenerService;
 import com.google.ipc.invalidation.ticl.android2.channel.AndroidGcmController;
 
 import org.chromium.base.ApplicationStatus;
@@ -33,62 +32,9 @@ import org.chromium.content_public.browser.UiThreadTaskTraits;
 /**
  * Receives Downstream messages and status of upstream messages from GCM.
  */
-public class ChromeGcmListenerService extends GcmListenerService {
+public class ChromeGcmListenerService {
     private static final String TAG = "ChromeGcmListener";
 
-    @Override
-    public void onCreate() {
-        ProcessInitializationHandler.getInstance().initializePreNative();
-        super.onCreate();
-    }
-
-    @Override
-    public void onMessageReceived(final String from, final Bundle data) {
-        boolean hasCollapseKey = !TextUtils.isEmpty(data.getString("collapse_key"));
-        GcmUma.recordDataMessageReceived(ContextUtils.getApplicationContext(), hasCollapseKey);
-
-        String invalidationSenderId = AndroidGcmController.get(this).getSenderId();
-        if (from.equals(invalidationSenderId)) {
-            AndroidGcmController.get(this).onMessageReceived(data);
-            return;
-        }
-
-        // Dispatch the message to the GCM Driver for native features.
-        PostTask.runOrPostTask(UiThreadTaskTraits.DEFAULT, () -> {
-            GCMMessage message = null;
-            try {
-                message = new GCMMessage(from, data);
-            } catch (IllegalArgumentException e) {
-                Log.e(TAG, "Received an invalid GCM Message", e);
-                return;
-            }
-
-            scheduleOrDispatchMessageToDriver(message);
-        });
-    }
-
-    @Override
-    public void onMessageSent(String msgId) {
-        Log.d(TAG, "Message sent successfully. Message id: " + msgId);
-        GcmUma.recordGcmUpstreamHistogram(
-                ContextUtils.getApplicationContext(), GcmUma.UMA_UPSTREAM_SUCCESS);
-    }
-
-    @Override
-    public void onSendError(String msgId, String error) {
-        Log.w(TAG, "Error in sending message. Message id: " + msgId + " Error: " + error);
-        GcmUma.recordGcmUpstreamHistogram(
-                ContextUtils.getApplicationContext(), GcmUma.UMA_UPSTREAM_SEND_FAILED);
-    }
-
-    @Override
-    public void onDeletedMessages() {
-        // TODO(johnme): Ask GCM to include the subtype in this event.
-        Log.w(TAG, "Push messages were deleted, but we can't tell the Service Worker as we don't"
-                + "know what subtype (app ID) it occurred for.");
-        GcmUma.recordDeletedMessages(ContextUtils.getApplicationContext());
-    }
-
     /**
      * If Chrome is backgrounded, messages coming from lazy subscriptions are
      * persisted on disk and replayed next time Chrome is forgrounded. If Chrome is forgrounded or
@@ -149,8 +95,6 @@ public class ChromeGcmListenerService extends GcmListenerService {
 
         try {
             ChromeBrowserInitializer.getInstance(applicationContext).handleSynchronousStartup();
-            GCMDriver.dispatchMessage(message);
-
         } catch (ProcessInitException e) {
             Log.e(TAG, "ProcessInitException while starting the browser process");
 
diff --git a/components/background_task_scheduler/BUILD.gn b/components/background_task_scheduler/BUILD.gn
--- a/components/background_task_scheduler/BUILD.gn
+++ b/components/background_task_scheduler/BUILD.gn
@@ -53,7 +53,6 @@ if (is_android) {
       ":background_task_scheduler_task_ids_java",
       "$google_play_services_package:google_play_services_base_java",
       "$google_play_services_package:google_play_services_basement_java",
-      "$google_play_services_package:google_play_services_gcm_java",
       "$google_play_services_package:google_play_services_tasks_java",
       "//base:base_java",
       "//third_party/android_deps:com_android_support_support_annotations_java",
@@ -73,7 +72,6 @@ if (is_android) {
       ":background_task_scheduler_task_ids_java",
       "$google_play_services_package:google_play_services_base_java",
       "$google_play_services_package:google_play_services_basement_java",
-      "$google_play_services_package:google_play_services_gcm_java",
       "$google_play_services_package:google_play_services_tasks_java",
       "//base:base_java",
       "//base:base_java_test_support",
@@ -98,7 +96,6 @@ if (is_android) {
       "$google_play_services_package:google_play_services_auth_base_java",
       "$google_play_services_package:google_play_services_base_java",
       "$google_play_services_package:google_play_services_basement_java",
-      "$google_play_services_package:google_play_services_gcm_java",
       "$google_play_services_package:google_play_services_tasks_java",
       "//base:base_java",
       "//base:base_java_test_support",
diff --git a/components/background_task_scheduler/android/java/src/org/chromium/components/background_task_scheduler/BackgroundTaskGcmTaskService.java b/components/background_task_scheduler/android/java/src/org/chromium/components/background_task_scheduler/BackgroundTaskGcmTaskService.java
--- a/components/background_task_scheduler/android/java/src/org/chromium/components/background_task_scheduler/BackgroundTaskGcmTaskService.java
+++ b/components/background_task_scheduler/android/java/src/org/chromium/components/background_task_scheduler/BackgroundTaskGcmTaskService.java
@@ -6,10 +6,6 @@ package org.chromium.components.background_task_scheduler;
 
 import android.os.Build;
 
-import com.google.android.gms.gcm.GcmNetworkManager;
-import com.google.android.gms.gcm.GcmTaskService;
-import com.google.android.gms.gcm.TaskParams;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.base.Log;
 import org.chromium.base.ThreadUtils;
@@ -19,7 +15,7 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 /** Delegates calls out to various tasks that need to run in the background. */
-public class BackgroundTaskGcmTaskService extends GcmTaskService {
+public class BackgroundTaskGcmTaskService {
     private static final String TAG = "BkgrdTaskGcmTS";
 
     /** Class that waits for the processing to be done. */
@@ -81,53 +77,6 @@ public class BackgroundTaskGcmTaskService extends GcmTaskService {
         }
     }
 
-    @Override
-    public int onRunTask(TaskParams params) {
-        final BackgroundTask backgroundTask =
-                BackgroundTaskSchedulerGcmNetworkManager.getBackgroundTaskFromTaskParams(params);
-        if (backgroundTask == null) {
-            Log.w(TAG, "Failed to start task. Could not instantiate class.");
-            return GcmNetworkManager.RESULT_FAILURE;
-        }
-
-        final TaskParameters taskParams =
-                BackgroundTaskSchedulerGcmNetworkManager.getTaskParametersFromTaskParams(params);
-        final Waiter waiter = new Waiter(Waiter.MAX_TIMEOUT_SECONDS);
-
-        final AtomicBoolean taskNeedsBackgroundProcessing = new AtomicBoolean();
-        ThreadUtils.runOnUiThreadBlocking(new Runnable() {
-            @Override
-            public void run() {
-                BackgroundTaskSchedulerUma.getInstance().reportTaskStarted(taskParams.getTaskId());
-                taskNeedsBackgroundProcessing.set(
-                        backgroundTask.onStartTask(ContextUtils.getApplicationContext(), taskParams,
-                                new TaskFinishedCallbackGcmTaskService(waiter)));
-            }
-        });
-
-        if (!taskNeedsBackgroundProcessing.get()) return GcmNetworkManager.RESULT_SUCCESS;
-
-        waiter.startWaiting();
-
-        if (waiter.isRescheduleNeeded()) return GcmNetworkManager.RESULT_RESCHEDULE;
-        if (!waiter.hasTaskTimedOut()) return GcmNetworkManager.RESULT_SUCCESS;
-
-        final AtomicBoolean taskNeedsRescheduling = new AtomicBoolean();
-        ThreadUtils.runOnUiThreadBlocking(new Runnable() {
-            @Override
-            public void run() {
-                BackgroundTaskSchedulerUma.getInstance().reportTaskStopped(taskParams.getTaskId());
-                taskNeedsRescheduling.set(backgroundTask.onStopTask(
-                        ContextUtils.getApplicationContext(), taskParams));
-            }
-        });
-
-        if (taskNeedsRescheduling.get()) return GcmNetworkManager.RESULT_RESCHEDULE;
-
-        return GcmNetworkManager.RESULT_SUCCESS;
-    }
-
-    @Override
     public void onInitializeTasks() {
         // Ignore the event on OSs supporting JobScheduler.
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) return;
diff --git a/components/background_task_scheduler/android/java/src/org/chromium/components/background_task_scheduler/BackgroundTaskSchedulerFactory.java b/components/background_task_scheduler/android/java/src/org/chromium/components/background_task_scheduler/BackgroundTaskSchedulerFactory.java
--- a/components/background_task_scheduler/android/java/src/org/chromium/components/background_task_scheduler/BackgroundTaskSchedulerFactory.java
+++ b/components/background_task_scheduler/android/java/src/org/chromium/components/background_task_scheduler/BackgroundTaskSchedulerFactory.java
@@ -16,11 +16,7 @@ public final class BackgroundTaskSchedulerFactory {
     private static BackgroundTaskScheduler sInstance;
 
     static BackgroundTaskSchedulerDelegate getSchedulerDelegateForSdk(int sdkInt) {
-        if (sdkInt >= Build.VERSION_CODES.M) {
-            return new BackgroundTaskSchedulerJobService();
-        } else {
-            return new BackgroundTaskSchedulerGcmNetworkManager();
-        }
+        return new BackgroundTaskSchedulerJobService(); /* minSDK is 24 */
     }
 
     /**
diff --git a/components/background_task_scheduler/android/java/src/org/chromium/components/background_task_scheduler/BackgroundTaskSchedulerGcmNetworkManager.java b/components/background_task_scheduler/android/java/src/org/chromium/components/background_task_scheduler/BackgroundTaskSchedulerGcmNetworkManager.java
--- a/components/background_task_scheduler/android/java/src/org/chromium/components/background_task_scheduler/BackgroundTaskSchedulerGcmNetworkManager.java
+++ b/components/background_task_scheduler/android/java/src/org/chromium/components/background_task_scheduler/BackgroundTaskSchedulerGcmNetworkManager.java
@@ -8,14 +8,6 @@ import android.content.Context;
 import android.os.Bundle;
 import android.support.annotation.NonNull;
 
-import com.google.android.gms.common.ConnectionResult;
-import com.google.android.gms.common.GoogleApiAvailability;
-import com.google.android.gms.gcm.GcmNetworkManager;
-import com.google.android.gms.gcm.OneoffTask;
-import com.google.android.gms.gcm.PeriodicTask;
-import com.google.android.gms.gcm.Task;
-import com.google.android.gms.gcm.TaskParams;
-
 import org.chromium.base.Log;
 import org.chromium.base.ThreadUtils;
 import org.chromium.base.VisibleForTesting;
@@ -26,7 +18,7 @@ import java.util.concurrent.TimeUnit;
  * An implementation of {@link BackgroundTaskSchedulerDelegate} that uses the Play Services
  * {@link GcmNetworkManager} to schedule jobs.
  */
-class BackgroundTaskSchedulerGcmNetworkManager implements BackgroundTaskSchedulerDelegate {
+class BackgroundTaskSchedulerGcmNetworkManager {
     private static final String TAG = "BkgrdTaskSchedGcmNM";
 
     @VisibleForTesting
@@ -34,160 +26,6 @@ class BackgroundTaskSchedulerGcmNetworkManager implements BackgroundTaskSchedule
     @VisibleForTesting
     static final String BACKGROUND_TASK_EXTRAS_KEY = "_background_task_extras";
 
-    static BackgroundTask getBackgroundTaskFromTaskParams(@NonNull TaskParams taskParams) {
-        String backgroundTaskClassName = getBackgroundTaskClassFromTaskParams(taskParams);
-        return BackgroundTaskReflection.getBackgroundTaskFromClassName(backgroundTaskClassName);
-    }
-
-    private static String getBackgroundTaskClassFromTaskParams(@NonNull TaskParams taskParams) {
-        Bundle extras = taskParams.getExtras();
-        if (extras == null) return null;
-        return extras.getString(BACKGROUND_TASK_CLASS_KEY);
-    }
-
-    /**
-     * Retrieves the {@link TaskParameters} from the {@link TaskParams}, which are passed as
-     * one of the keys. Only values valid for {@link android.os.BaseBundle} are supported, and other
-     * values are stripped at the time when the task is scheduled.
-     *
-     * @param taskParams the {@link TaskParams} to extract the {@link TaskParameters} from.
-     * @return the {@link TaskParameters} for the current job.
-     */
-    static TaskParameters getTaskParametersFromTaskParams(@NonNull TaskParams taskParams) {
-        int taskId;
-        try {
-            taskId = Integer.parseInt(taskParams.getTag());
-        } catch (NumberFormatException e) {
-            Log.e(TAG, "Cound not parse task ID from task tag: " + taskParams.getTag());
-            return null;
-        }
-
-        TaskParameters.Builder builder = TaskParameters.create(taskId);
-
-        Bundle extras = taskParams.getExtras();
-        Bundle taskExtras = extras.getBundle(BACKGROUND_TASK_EXTRAS_KEY);
-        builder.addExtras(taskExtras);
-
-        return builder.build();
-    }
-
-    @VisibleForTesting
-    static Task createTaskFromTaskInfo(@NonNull TaskInfo taskInfo) {
-        Bundle taskExtras = new Bundle();
-        taskExtras.putString(
-                BACKGROUND_TASK_CLASS_KEY, taskInfo.getBackgroundTaskClass().getName());
-        taskExtras.putBundle(BACKGROUND_TASK_EXTRAS_KEY, taskInfo.getExtras());
-
-        Task.Builder builder;
-        if (taskInfo.isPeriodic()) {
-            builder = getPeriodicTaskBuilder(taskInfo.getPeriodicInfo());
-        } else {
-            builder = getOneOffTaskBuilder(taskInfo.getOneOffInfo());
-        }
-
-        builder.setExtras(taskExtras)
-                .setPersisted(taskInfo.isPersisted())
-                .setRequiredNetwork(getGcmNetworkManagerNetworkTypeFromTypeFromTaskNetworkType(
-                        taskInfo.getRequiredNetworkType()))
-                .setRequiresCharging(taskInfo.requiresCharging())
-                .setService(BackgroundTaskGcmTaskService.class)
-                .setTag(taskIdToTaskTag(taskInfo.getTaskId()))
-                .setUpdateCurrent(taskInfo.shouldUpdateCurrent());
-
-        return builder.build();
-    }
-
-    private static Task.Builder getPeriodicTaskBuilder(TaskInfo.PeriodicInfo periodicInfo) {
-        PeriodicTask.Builder builder = new PeriodicTask.Builder();
-        builder.setPeriod(TimeUnit.MILLISECONDS.toSeconds(periodicInfo.getIntervalMs()));
-        if (periodicInfo.hasFlex()) {
-            builder.setFlex(TimeUnit.MILLISECONDS.toSeconds(periodicInfo.getFlexMs()));
-        }
-        return builder;
-    }
-
-    private static Task.Builder getOneOffTaskBuilder(TaskInfo.OneOffInfo oneOffInfo) {
-        OneoffTask.Builder builder = new OneoffTask.Builder();
-        long windowStartSeconds = oneOffInfo.hasWindowStartTimeConstraint()
-                ? TimeUnit.MILLISECONDS.toSeconds(oneOffInfo.getWindowStartTimeMs())
-                : 0;
-        builder.setExecutionWindow(windowStartSeconds,
-                TimeUnit.MILLISECONDS.toSeconds(oneOffInfo.getWindowEndTimeMs()));
-        return builder;
-    }
-
-    private static int getGcmNetworkManagerNetworkTypeFromTypeFromTaskNetworkType(
-            @TaskInfo.NetworkType int networkType) {
-        switch (networkType) {
-            // This is correct: GcmNM ANY means no network is guaranteed.
-            case TaskInfo.NetworkType.NONE:
-                return Task.NETWORK_STATE_ANY;
-            case TaskInfo.NetworkType.ANY:
-                return Task.NETWORK_STATE_CONNECTED;
-            case TaskInfo.NetworkType.UNMETERED:
-                return Task.NETWORK_STATE_UNMETERED;
-            default:
-                assert false;
-        }
-        return Task.NETWORK_STATE_ANY;
-    }
-
-    @Override
-    public boolean schedule(Context context, @NonNull TaskInfo taskInfo) {
-        ThreadUtils.assertOnUiThread();
-        if (!BackgroundTaskReflection.hasParameterlessPublicConstructor(
-                    taskInfo.getBackgroundTaskClass())) {
-            Log.e(TAG,
-                    "BackgroundTask " + taskInfo.getBackgroundTaskClass()
-                            + " has no parameterless public constructor.");
-            return false;
-        }
-
-        GcmNetworkManager gcmNetworkManager = getGcmNetworkManager(context);
-        if (gcmNetworkManager == null) {
-            Log.e(TAG, "GcmNetworkManager is not available.");
-            return false;
-        }
-
-        try {
-            Task task = createTaskFromTaskInfo(taskInfo);
-            gcmNetworkManager.schedule(task);
-        } catch (IllegalArgumentException e) {
-            String gcmErrorMessage = e.getMessage() == null ? "null." : e.getMessage();
-            Log.e(TAG,
-                    "GcmNetworkManager failed to schedule task, gcm message: " + gcmErrorMessage);
-            return false;
-        }
-
-        return true;
-    }
-
-    @Override
-    public void cancel(Context context, int taskId) {
-        ThreadUtils.assertOnUiThread();
-
-        GcmNetworkManager gcmNetworkManager = getGcmNetworkManager(context);
-        if (gcmNetworkManager == null) {
-            Log.e(TAG, "GcmNetworkManager is not available.");
-            return;
-        }
-
-        try {
-            gcmNetworkManager.cancelTask(
-                    taskIdToTaskTag(taskId), BackgroundTaskGcmTaskService.class);
-        } catch (IllegalArgumentException e) {
-            Log.e(TAG, "GcmNetworkManager failed to cancel task.");
-        }
-    }
-
-    private GcmNetworkManager getGcmNetworkManager(Context context) {
-        if (GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(context)
-                == ConnectionResult.SUCCESS) {
-            return GcmNetworkManager.getInstance(context);
-        }
-        return null;
-    }
-
     private static String taskIdToTaskTag(int taskId) {
         return Integer.toString(taskId);
     }
diff --git a/third_party/android_deps/BUILD.gn b/third_party/android_deps/BUILD.gn
--- a/third_party/android_deps/BUILD.gn
+++ b/third_party/android_deps/BUILD.gn
@@ -417,21 +417,6 @@ android_aar_prebuilt("google_play_services_fido_java") {
   strip_drawables = true
 }
 
-# This is generated, do not edit. Update BuildConfigGenerator.groovy instead.
-android_aar_prebuilt("google_play_services_gcm_java") {
-  aar_path = "libs/com_google_android_gms_play_services_gcm/play-services-gcm-15.0.1.aar"
-  info_path = "libs/com_google_android_gms_play_services_gcm/com_google_android_gms_play_services_gcm.info"
-  deps = [
-    ":google_play_services_base_java",
-    ":google_play_services_basement_java",
-    ":google_play_services_iid_java",
-    ":google_play_services_stats_java",
-  ]
-
-  # Removing drawables from GMS .aars as they are unused bloat.
-  strip_drawables = true
-}
-
 # This is generated, do not edit. Update BuildConfigGenerator.groovy instead.
 android_aar_prebuilt("google_play_services_iid_java") {
   aar_path = "libs/com_google_android_gms_play_services_iid/play-services-iid-15.0.1.aar"
diff --git a/third_party/cacheinvalidation/BUILD.gn b/third_party/cacheinvalidation/BUILD.gn
--- a/third_party/cacheinvalidation/BUILD.gn
+++ b/third_party/cacheinvalidation/BUILD.gn
@@ -137,7 +137,6 @@ if (is_android) {
     jacoco_never_instrument = true
     deps = [
       ":cacheinvalidation_proto_java",
-      "$google_play_services_package:google_play_services_gcm_java",
       "$google_play_services_package:google_play_services_iid_java",
       "$google_play_services_package:google_play_services_tasks_java",
       "//base:base_java",
diff --git a/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/external/client/android2/AndroidManifestUpdatedGcm.xml b/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/external/client/android2/AndroidManifestUpdatedGcm.xml
--- a/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/external/client/android2/AndroidManifestUpdatedGcm.xml
+++ b/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/external/client/android2/AndroidManifestUpdatedGcm.xml
@@ -24,17 +24,6 @@
     <receiver android:exported="false"
         android:name="com.google.ipc.invalidation.ticl2.android2.AndroidInternalScheduler$AlarmReceiver"/>
 
-    <!-- GCM Broadcast Receiver -->
-    <receiver android:exported="true"
-        android:name="com.google.android.gms.gcm.GcmReceiver"
-        android:permission="com.google.android.c2dm.permission.SEND">
-        <intent-filter>
-            <action android:name="com.google.android.c2dm.intent.RECEIVE" />
-            <action android:name="com.google.android.c2dm.intent.REGISTRATION" />
-            <category android:name="com.google.ipc.invalidation.client2.android2"/>
-        </intent-filter>
-    </receiver>
-
     <!-- InstanceID Listener Service -->
     <service android:exported="false"
         android:name="com.google.ipc.invalidation.ticl2.android2.channel.AndroidInstanceIDListenerService">
@@ -42,14 +31,5 @@
             <action android:name="com.google.android.gms.iid.InstanceID"/>
         </intent-filter>
     </service>
-
-    <!-- GcmTaskService for registration -->
-    <service android:name="com.google.ipc.invalidation.ticl2.android2.channel.GcmRegistrationTaskService"
-        android:exported="true"
-        android:permission="com.google.android.gms.permission.BIND_NETWORK_TASK_SERVICE" >
-        <intent-filter>
-            <action android:name="com.google.android.gms.gcm.ACTION_TASK_READY" />
-        </intent-filter>
-    </service>
   </application>
 </manifest>
diff --git a/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidGcmController.java b/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidGcmController.java
--- a/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidGcmController.java
+++ b/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidGcmController.java
@@ -15,8 +15,6 @@
  */
 package com.google.ipc.invalidation.ticl.android2.channel;
 
-import com.google.android.gms.gcm.GcmNetworkManager;
-import com.google.android.gms.gcm.OneoffTask;
 import com.google.ipc.invalidation.common.GcmSharedConstants;
 import com.google.ipc.invalidation.external.client.SystemResources.Logger;
 import com.google.ipc.invalidation.external.client.android.service.AndroidLogger;
@@ -50,7 +48,7 @@ public class AndroidGcmController {
 
   private static AndroidGcmController androidGcmController;
 
-  private GcmNetworkManager gcmNetworkManager;
+//  private GcmNetworkManager gcmNetworkManager;
 
   private Context context;
 
@@ -64,32 +62,12 @@ public class AndroidGcmController {
   public static AndroidGcmController get(Context context) {
     synchronized (lock) {
       if (androidGcmController == null) {
-        androidGcmController =
-            new AndroidGcmController(context, GcmNetworkManager.getInstance(context));
+        androidGcmController = null;
       }
     }
     return androidGcmController;
   }
 
-  /**
-   * Override AndroidGcmController with a custom GcmNetworkManager in tests. This overrides the
-   * existing instance of AndroidGcmController if any.
-   *
-   * @param context the application context.
-   * @param gcmNetworkManager the custom GcmNetworkManager to use.
-   */
-  public static void overrideAndroidGcmControllerForTests(
-      Context context, GcmNetworkManager gcmNetworkManager) {
-    synchronized (lock) {
-      androidGcmController = new AndroidGcmController(context, gcmNetworkManager);
-    }
-  }
-
-  private AndroidGcmController(Context context, GcmNetworkManager gcmNetworkManager) {
-    this.context = context;
-    this.gcmNetworkManager = gcmNetworkManager;
-  }
-
   /**
    * Returns true if no registration token is stored or the current application version is higher
    * than the version for the token stored.
@@ -142,21 +120,7 @@ public class AndroidGcmController {
       return;
     }
 
-    OneoffTask registrationTask =
-        new OneoffTask.Builder()
-            .setExecutionWindow(0, 1)
-            .setTag(AndroidChannelConstants.GCM_REGISTRATION_TASK_SERVICE_TAG)
-            .setService(GcmRegistrationTaskService.class)
-            .build();
-
-    try {
-      gcmNetworkManager.schedule(registrationTask);
-    } catch (IllegalArgumentException exception) {
-      // Scheduling the service can throw an exception due to a framework error on Android when
-      // the the look up for the GCMTaskService being scheduled to be run fails.
-      // See crbug/548314.
-      logger.warning("Failed to schedule GCM registration task. Exception: %s", exception);
-    }
+    logger.warning("Failed to schedule GCM registration task.");
   }
 
   /**
diff --git a/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidInstanceIDListenerService.java b/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidInstanceIDListenerService.java
--- a/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidInstanceIDListenerService.java
+++ b/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidInstanceIDListenerService.java
@@ -15,7 +15,6 @@
  */
 package com.google.ipc.invalidation.ticl.android2.channel;
 
-import com.google.android.gms.iid.InstanceIDListenerService;
 import com.google.ipc.invalidation.external.client.SystemResources.Logger;
 import com.google.ipc.invalidation.external.client.android.service.AndroidLogger;
 
@@ -23,16 +22,6 @@ import com.google.ipc.invalidation.external.client.android.service.AndroidLogger
  * Implementation of {@link InstanceIDListenerService} to receive notifications from GCM to
  * update the registration token.
  */
-public class AndroidInstanceIDListenerService extends InstanceIDListenerService {
+public class AndroidInstanceIDListenerService {
   private static final Logger logger = AndroidLogger.forTag("InstanceIDListener");
-  
-  /**
-   * Called when the token needs to updated. {@link AndroidGcmController#fetchToken} clears the
-   * current token and schedules a task to fetch a new token.
-   */
-  @Override
-  public void onTokenRefresh() {
-    logger.info("Received token refresh request");
-    AndroidGcmController.get(this).fetchToken();
-  }
 }
diff --git a/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/ticl/android2/channel/GcmRegistrationTaskService.java b/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/ticl/android2/channel/GcmRegistrationTaskService.java
--- a/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/ticl/android2/channel/GcmRegistrationTaskService.java
+++ b/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/ticl/android2/channel/GcmRegistrationTaskService.java
@@ -15,11 +15,6 @@
  */
 package com.google.ipc.invalidation.ticl.android2.channel;
 
-import com.google.android.gms.gcm.GcmNetworkManager;
-import com.google.android.gms.gcm.GcmTaskService;
-import com.google.android.gms.gcm.GoogleCloudMessaging;
-import com.google.android.gms.gcm.TaskParams;
-import com.google.android.gms.iid.InstanceID;
 import com.google.ipc.invalidation.common.GcmSharedConstants;
 import com.google.ipc.invalidation.external.client.SystemResources.Logger;
 import com.google.ipc.invalidation.external.client.android.service.AndroidLogger;
@@ -42,88 +37,6 @@ import java.io.IOException;
  * failure to fetch the token, the task is rescheduled using the GcmNetworkManager which uses
  * exponential back-offs to control when the task is executed.
  */
-public class GcmRegistrationTaskService extends GcmTaskService {
+public class GcmRegistrationTaskService {
   private static final Logger logger = AndroidLogger.forTag("RegistrationTaskService");
-
-  public InstanceID getInstanceID(Context context) {
-    return InstanceID.getInstance(context);
-  }
-
-  /**
-   * Called when the task is ready to be executed. Registers with GCM using
-   * {@link InstanceID#getToken} and stores the registration token.
-   *
-   * <p>Returns {@link GcmNetworkManager#RESULT_SUCCESS} when the token is successfully retrieved.
-   * On failure {@link GcmNetworkManager#RESULT_RESCHEDULE} is used which reschedules the service
-   * to be executed again using exponential back-off.
-   */
-  @Override
-  public int onRunTask(TaskParams params) {
-    if (!AndroidChannelConstants.GCM_REGISTRATION_TASK_SERVICE_TAG.equals(params.getTag())) {
-     logger.warning("Unknown task received with tag: %s", params.getTag());
-     return GcmNetworkManager.RESULT_FAILURE;
-    }
-
-    String senderId = GcmSharedConstants.GCM_UPDATED_SENDER_ID;
-    try {
-      String token = getInstanceID(this).getToken(
-          senderId, GoogleCloudMessaging.INSTANCE_ID_SCOPE, null);
-      storeToken(token);
-      return GcmNetworkManager.RESULT_SUCCESS;
-    } catch (IOException exception) {
-      logger.warning("Failed to get token for sender: %s. Exception : %s", senderId, exception);
-      return GcmNetworkManager.RESULT_RESCHEDULE;
-    } catch (SecurityException exception) {
-      // InstanceID#getToken occasionally throws a security exception when trying send the
-      // registration intent to GMSCore. Catching the exception here to prevent crashes.
-      logger.warning("Security exception when fetching token: %s", exception);
-      return GcmNetworkManager.RESULT_RESCHEDULE;
-    }
-  }
-
-  /** Stores the registration token and the current application version in Shared Preferences. */
-  private void storeToken(String token) {
-      AndroidChannelPreferences.setRegistrationToken(token);
-      AndroidChannelPreferences.setAppVersion(
-              CommonUtils.getPackageVersion(this, getPackageName()));
-      // Send the updated token to the server.
-      updateServer();
-  }
-
-  /** Sends a message to the server to update the GCM registration token. */
-  private void updateServer() {
-    // Inform the sender service that the registration token has changed. If the sender service
-    // had buffered a message because no registration token was previously available, this intent
-    // will cause it to send that message.
-    Intent sendBuffered = new Intent();
-    final String ignoredData = "";
-    sendBuffered.putExtra(AndroidChannelConstants.MESSAGE_SENDER_SVC_GCM_REGID_CHANGE, ignoredData);
-
-    // Select the sender service to use for upstream message.
-    if (AndroidChannelPreferences.getGcmChannelType() == GcmChannelType.GCM_UPSTREAM) {
-        String upstreamServiceClass = new AndroidTiclManifest(this).getGcmUpstreamServiceClass();
-        if (upstreamServiceClass == null) {
-            logger.warning("GcmUpstreamSenderService class not found.");
-            return;
-        }
-        sendBuffered.setClassName(this, upstreamServiceClass);
-    } else {
-        sendBuffered.setClass(this, AndroidMessageSenderService.class);
-    }
-    try {
-      startService(sendBuffered);
-    } catch (IllegalStateException exception) {
-      logger.warning("Unable to send buffered message(s): %s", exception);
-    }
-
-    // Inform the Ticl service that the registration id has changed. This will cause it to send
-    // a message to the data center and update the GCM registration id stored at the data center.
-    Intent updateServer = ProtocolIntents.InternalDowncalls.newNetworkAddrChangeIntent();
-    updateServer.setClassName(this, new AndroidTiclManifest(this).getTiclServiceClass());
-    try {
-      startService(updateServer);
-    } catch (IllegalStateException exception) {
-      logger.warning("Unable to inform server about new registration id: %s", exception);
-    }
-  }
 }
