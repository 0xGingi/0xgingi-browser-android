From: Wengling Chen <feiyu2817@gmail.com>
Date: Sat, 2 Nov 2019 07:58:48 +0100
Subject: Remove dependency on com.google.android.gms.fido,
 com.google.android.gms.iid, com.google.android.gms.instantapps,
 com.google.android.gms.location

---
 base/android/java/src/org/chromium/base/IntentUtils.java                                                                              |    5 
 chrome/android/BUILD.gn                                                                                                               |    5 
 chrome/android/features/cablev2_authenticator/BUILD.gn                                                                                |    1 
 chrome/android/features/cablev2_authenticator/java/src/org/chromium/chrome/browser/webauth/authenticator/CableAuthenticator.java      |  221 ------
 chrome/android/java/src/org/chromium/chrome/browser/externalnav/ExternalNavigationDelegateImpl.java                                   |    6 
 chrome/android/java/src/org/chromium/chrome/browser/instantapps/InstantAppsHandler.java                                               |   51 -
 chrome/android/java/src/org/chromium/chrome/browser/webauth/Fido2CredentialRequest.java                                               |  181 -----
 chrome/android/java/src/org/chromium/chrome/browser/webauth/Fido2Helper.java                                                          |  335 ----------
 components/gcm_driver/instance_id/android/BUILD.gn                                                                                    |    2 
 components/gcm_driver/instance_id/android/java/src/org/chromium/components/gcm_driver/instance_id/InstanceIDWithSubtype.java          |   28 
 components/gcm_driver/instance_id/android/javatests/src/org/chromium/components/gcm_driver/instance_id/FakeInstanceIDWithSubtype.java |   14 
 device/BUILD.gn                                                                                                                       |    1 
 services/BUILD.gn                                                                                                                     |    1 
 services/device/geolocation/BUILD.gn                                                                                                  |    1 
 services/device/geolocation/android/java/src/org/chromium/device/geolocation/LocationProviderGmsCore.java                             |  103 ---
 third_party/android_deps/BUILD.gn                                                                                                     |   60 -
 third_party/cacheinvalidation/BUILD.gn                                                                                                |    1 
 third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/external/client/android2/AndroidManifestUpdatedGcm.xml             |    3 
 18 files changed, 26 insertions(+), 993 deletions(-)

--- a/chrome/android/BUILD.gn
+++ b/chrome/android/BUILD.gn
@@ -274,8 +274,6 @@ android_library("chrome_java") {
     ":usage_stats_proto_java",
     "$google_play_services_package:google_play_services_base_java",
     "$google_play_services_package:google_play_services_basement_java",
-    "$google_play_services_package:google_play_services_fido_java",
-    "$google_play_services_package:google_play_services_iid_java",
     "$google_play_services_package:google_play_services_tasks_java",
     "$google_play_services_package:google_play_services_vision_common_java",
     "$google_play_services_package:google_play_services_vision_java",
@@ -724,7 +722,6 @@ junit_binary("chrome_junit_tests") {
     ":partner_location_descriptor_proto_java",
     "$google_play_services_package:google_play_services_base_java",
     "$google_play_services_package:google_play_services_basement_java",
-    "$google_play_services_package:google_play_services_fido_java",
     "//base:base_java",
     "//base:base_java_test_support",
     "//base:base_junit_test_support",
@@ -903,8 +900,6 @@ android_library("chrome_test_java") {
     ":partner_location_descriptor_proto_java",
     "$google_play_services_package:google_play_services_base_java",
     "$google_play_services_package:google_play_services_basement_java",
-    "$google_play_services_package:google_play_services_fido_java",
-    "$google_play_services_package:google_play_services_iid_java",
     "$google_play_services_package:google_play_services_tasks_java",
     "//base:base_java",
     "//base:base_java_test_support",
--- a/chrome/android/java/src/org/chromium/chrome/browser/instantapps/InstantAppsHandler.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/instantapps/InstantAppsHandler.java
@@ -40,31 +40,6 @@ public class InstantAppsHandler {
     // TODO(mariakhomenko): Use system once we roll to O SDK.
     private static final int FLAG_DO_NOT_LAUNCH = 0x00000200;
 
-    // TODO(mariakhomenko): Depend directly on the constants once we roll to v8 libraries.
-    private static final String DO_NOT_LAUNCH_EXTRA =
-            "com.google.android.gms.instantapps.DO_NOT_LAUNCH_INSTANT_APP";
-
-    protected static final String IS_REFERRER_TRUSTED_EXTRA =
-            "com.google.android.gms.instantapps.IS_REFERRER_TRUSTED";
-
-    protected static final String IS_USER_CONFIRMED_LAUNCH_EXTRA =
-            "com.google.android.gms.instantapps.IS_USER_CONFIRMED_LAUNCH";
-
-    protected static final String TRUSTED_REFERRER_PKG_EXTRA =
-            "com.google.android.gms.instantapps.TRUSTED_REFERRER_PKG";
-
-    public static final String IS_GOOGLE_SEARCH_REFERRER =
-            "com.google.android.gms.instantapps.IS_GOOGLE_SEARCH_REFERRER";
-
-    private static final String BROWSER_LAUNCH_REASON =
-            "com.google.android.gms.instantapps.BROWSER_LAUNCH_REASON";
-
-    private static final String SUPERVISOR_PKG = "com.google.android.instantapps.supervisor";
-
-    private static final String[] SUPERVISOR_START_ACTIONS = {
-            "com.google.android.instantapps.START", "com.google.android.instantapps.nmr1.INSTALL",
-            "com.google.android.instantapps.nmr1.VIEW"};
-
     /** Finch experiment name. */
     private static final String INSTANT_APPS_EXPERIMENT_NAME = "InstantApps";
 
@@ -93,14 +68,6 @@ public class InstantAppsHandler {
      * @return Whether the given intent is going to open an Instant App.
      */
     public static boolean isIntentToInstantApp(Intent intent) {
-        if (SUPERVISOR_PKG.equals(intent.getPackage())) return true;
-
-        String intentAction = intent.getAction();
-        for (String action : SUPERVISOR_START_ACTIONS) {
-            if (action.equals(intentAction)) {
-                return true;
-            }
-        }
         return false;
     }
 
@@ -141,14 +108,7 @@ public class InstantAppsHandler {
                     SystemClock.elapsedRealtime() - startTime);
             intent.removeExtra(INSTANT_APP_START_TIME_EXTRA);
         }
-        int callSource = IntentUtils.safeGetIntExtra(intent, BROWSER_LAUNCH_REASON, 0);
-        if (callSource > 0 && callSource < SOURCE_BOUNDARY) {
-            RecordHistogram.recordEnumeratedHistogram(
-                    "Android.InstantApps.CallSource", callSource, SOURCE_BOUNDARY);
-            intent.removeExtra(BROWSER_LAUNCH_REASON);
-        } else if (callSource >= SOURCE_BOUNDARY) {
-            Log.e(TAG, "Unexpected call source constant for Instant Apps: " + callSource);
-        }
+        Log.e(TAG, "Unexpected call source constant for Instant Apps");
     }
 
     /**
@@ -183,9 +143,8 @@ public class InstantAppsHandler {
             return false;
         }
 
-        if (IntentUtils.safeGetBooleanExtra(intent, DO_NOT_LAUNCH_EXTRA, false)
-                || (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O
-                           && (intent.getFlags() & FLAG_DO_NOT_LAUNCH) != 0)) {
+        if ((Build.VERSION.SDK_INT >= Build.VERSION_CODES.O
+                && (intent.getFlags() & FLAG_DO_NOT_LAUNCH) != 0)) {
             maybeRecordFallbackStats(intent);
             Log.i(TAG, "Not handling with Instant Apps (DO_NOT_LAUNCH_EXTRA)");
             return false;
@@ -215,7 +174,6 @@ public class InstantAppsHandler {
         }
 
         Intent callbackIntent = new Intent(intent);
-        callbackIntent.putExtra(DO_NOT_LAUNCH_EXTRA, true);
         callbackIntent.putExtra(INSTANT_APP_START_TIME_EXTRA, startTime);
 
         return tryLaunchingInstantApp(context, intent, isCustomTabsIntent, callbackIntent);
@@ -318,12 +276,9 @@ public class InstantAppsHandler {
         Intent iaIntent = data.getIntent();
         if (data.getReferrer() != null) {
             iaIntent.putExtra(Intent.EXTRA_REFERRER, data.getReferrer());
-            iaIntent.putExtra(IS_REFERRER_TRUSTED_EXTRA, true);
         }
 
         Context appContext = ContextUtils.getApplicationContext();
-        iaIntent.putExtra(TRUSTED_REFERRER_PKG_EXTRA, appContext.getPackageName());
-        iaIntent.putExtra(IS_USER_CONFIRMED_LAUNCH_EXTRA, true);
 
         try {
             appContext.startActivity(iaIntent);
--- a/components/gcm_driver/instance_id/android/BUILD.gn
+++ b/components/gcm_driver/instance_id/android/BUILD.gn
@@ -15,7 +15,6 @@ generate_jni("test_support_jni_headers")
 
 android_library("instance_id_driver_java") {
   deps = [
-    "$google_play_services_package:google_play_services_iid_java",
     "//base:base_java",
     "//base:jni_java",
     "//components/gcm_driver/android:gcm_driver_java",
@@ -33,7 +32,6 @@ android_library("instance_id_driver_java
 android_library("instance_id_driver_test_support_java") {
   deps = [
     ":instance_id_driver_java",
-    "$google_play_services_package:google_play_services_iid_java",
     "//base:base_java",
   ]
 
--- a/components/gcm_driver/instance_id/android/java/src/org/chromium/components/gcm_driver/instance_id/InstanceIDWithSubtype.java
+++ b/components/gcm_driver/instance_id/android/java/src/org/chromium/components/gcm_driver/instance_id/InstanceIDWithSubtype.java
@@ -10,8 +10,6 @@ import android.text.TextUtils;
 
 import androidx.annotation.VisibleForTesting;
 
-import com.google.android.gms.iid.InstanceID;
-
 import org.chromium.base.ContextUtils;
 
 import java.io.IOException;
@@ -26,8 +24,6 @@ public class InstanceIDWithSubtype {
     // Must match the private InstanceID.OPTION_SUBTYPE, which is guaranteed to not change.
     private static final String OPTION_SUBTYPE = "subtype";
 
-    private final InstanceID mInstanceID;
-
     /**
      * Cached instances. May be accessed from multiple threads; synchronize on sSubtypeInstancesLock
      */
@@ -39,10 +35,6 @@ public class InstanceIDWithSubtype {
     @VisibleForTesting
     protected static FakeFactory sFakeFactoryForTesting;
 
-    protected InstanceIDWithSubtype(InstanceID instanceID) {
-        mInstanceID = instanceID;
-    }
-
     /**
      * Returns an instance of this class. Unlike {@link InstanceID#getInstance(Context)}, it is not
      * a singleton, but instead a different instance will be returned for each {@code subtype}.
@@ -58,11 +50,6 @@ public class InstanceIDWithSubtype {
                 if (sFakeFactoryForTesting != null) {
                     existing = sFakeFactoryForTesting.create(subtype);
                 } else {
-                    Bundle options = new Bundle();
-                    options.putCharSequence(OPTION_SUBTYPE, subtype);
-                    InstanceID instanceID =
-                            InstanceID.getInstance(ContextUtils.getApplicationContext(), options);
-                    existing = new InstanceIDWithSubtype(instanceID);
                 }
                 sSubtypeInstances.put(subtype, existing);
             }
@@ -71,35 +58,30 @@ public class InstanceIDWithSubtype {
     }
 
     public String getSubtype() {
-        return mInstanceID.getSubtype();
+        return "";
     }
 
     public String getId() {
-        return mInstanceID.getId();
+        return "";
     }
 
     public long getCreationTime() {
-        return mInstanceID.getCreationTime();
+        return 0;
     }
 
     public void deleteInstanceID() throws IOException {
-        synchronized (sSubtypeInstancesLock) {
-            sSubtypeInstances.remove(mInstanceID.getSubtype());
-            mInstanceID.deleteInstanceID();
-        }
     }
 
     public void deleteToken(String authorizedEntity, String scope) throws IOException {
-        mInstanceID.deleteToken(authorizedEntity, scope);
     }
 
     public String getToken(String authorizedEntity, String scope) throws IOException {
-        return mInstanceID.getToken(authorizedEntity, scope);
+        return "";
     }
 
     public String getToken(String authorizedEntity, String scope, Bundle extras)
             throws IOException {
-        return mInstanceID.getToken(authorizedEntity, scope, extras);
+        return "";
     }
 
     /** Fake subclasses can set {@link #sFakeFactoryForTesting} to an implementation of this. */
--- a/device/BUILD.gn
+++ b/device/BUILD.gn
@@ -395,7 +395,6 @@ if (is_android) {
     deps = [
       "$google_play_services_package:google_play_services_base_java",
       "$google_play_services_package:google_play_services_basement_java",
-      "$google_play_services_package:google_play_services_location_java",
       "//base:base_java",
       "//base:base_java_test_support",
       "//base:base_junit_test_support",
--- a/services/device/geolocation/BUILD.gn
+++ b/services/device/geolocation/BUILD.gn
@@ -158,7 +158,6 @@ if (is_android) {
       ":geolocation_jni_headers",
       "$google_play_services_package:google_play_services_base_java",
       "$google_play_services_package:google_play_services_basement_java",
-      "$google_play_services_package:google_play_services_location_java",
       "//base:base_java",
       "//base:jni_java",
       "//components/location/android:location_java",
--- a/services/device/geolocation/android/java/src/org/chromium/device/geolocation/LocationProviderGmsCore.java
+++ b/services/device/geolocation/android/java/src/org/chromium/device/geolocation/LocationProviderGmsCore.java
@@ -8,16 +8,6 @@ import android.content.Context;
 import android.location.Location;
 import android.os.Bundle;
 
-import com.google.android.gms.common.ConnectionResult;
-import com.google.android.gms.common.GoogleApiAvailability;
-import com.google.android.gms.common.api.GoogleApiClient;
-import com.google.android.gms.common.api.GoogleApiClient.ConnectionCallbacks;
-import com.google.android.gms.common.api.GoogleApiClient.OnConnectionFailedListener;
-import com.google.android.gms.location.FusedLocationProviderApi;
-import com.google.android.gms.location.LocationListener;
-import com.google.android.gms.location.LocationRequest;
-import com.google.android.gms.location.LocationServices;
-
 import org.chromium.base.Log;
 import org.chromium.base.ThreadUtils;
 import org.chromium.components.location.LocationUtils;
@@ -27,126 +17,39 @@ import org.chromium.components.location.
  *
  * https://developers.google.com/android/reference/com/google/android/gms/location/package-summary
  */
-public class LocationProviderGmsCore implements ConnectionCallbacks, OnConnectionFailedListener,
-                                                LocationListener, LocationProvider {
+public class LocationProviderGmsCore implements LocationProvider {
     private static final String TAG = "LocationProvider";
 
     // Values for the LocationRequest's setInterval for normal and high accuracy, respectively.
     private static final long UPDATE_INTERVAL_MS = 1000;
     private static final long UPDATE_INTERVAL_FAST_MS = 500;
 
-    private final GoogleApiClient mGoogleApiClient;
-    private FusedLocationProviderApi mLocationProviderApi = LocationServices.FusedLocationApi;
-
     private boolean mEnablehighAccuracy;
-    private LocationRequest mLocationRequest;
 
     public static boolean isGooglePlayServicesAvailable(Context context) {
-        return GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(context)
-                == ConnectionResult.SUCCESS;
+        return false;
     }
 
     LocationProviderGmsCore(Context context) {
         Log.i(TAG, "Google Play Services");
-        mGoogleApiClient = new GoogleApiClient.Builder(context)
-                                   .addApi(LocationServices.API)
-                                   .addConnectionCallbacks(this)
-                                   .addOnConnectionFailedListener(this)
-                                   .build();
-        assert mGoogleApiClient != null;
-    }
-
-    LocationProviderGmsCore(GoogleApiClient client, FusedLocationProviderApi locationApi) {
-        mGoogleApiClient = client;
-        mLocationProviderApi = locationApi;
-    }
-
-    // ConnectionCallbacks implementation
-    @Override
-    public void onConnected(Bundle connectionHint) {
-        ThreadUtils.assertOnUiThread();
-
-        mLocationRequest = LocationRequest.create();
-        if (mEnablehighAccuracy) {
-            // With enableHighAccuracy, request a faster update interval and configure the provider
-            // for high accuracy mode.
-            mLocationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY)
-                    .setInterval(UPDATE_INTERVAL_FAST_MS);
-        } else {
-            // Use balanced mode by default. In this mode, the API will prefer the network provider
-            // but may use sensor data (for instance, GPS) if high accuracy is requested by another
-            // app.
-            //
-            // If location is configured for sensors-only then elevate the priority to ensure GPS
-            // and other sensors are used.
-            if (LocationUtils.getInstance().isSystemLocationSettingSensorsOnly()) {
-                mLocationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);
-            } else {
-                mLocationRequest.setPriority(LocationRequest.PRIORITY_BALANCED_POWER_ACCURACY);
-            }
-            mLocationRequest.setInterval(UPDATE_INTERVAL_MS);
-        }
-
-        final Location location = mLocationProviderApi.getLastLocation(mGoogleApiClient);
-        if (location != null) {
-            LocationProviderAdapter.onNewLocationAvailable(location);
-        }
-
-        try {
-            // Request updates on UI Thread replicating LocationProviderAndroid's behaviour.
-            mLocationProviderApi.requestLocationUpdates(
-                    mGoogleApiClient, mLocationRequest, this, ThreadUtils.getUiThreadLooper());
-        } catch (IllegalStateException | SecurityException e) {
-            // IllegalStateException is thrown "If this method is executed in a thread that has not
-            // called Looper.prepare()". SecurityException is thrown if there is no permission, see
-            // https://crbug.com/731271.
-            Log.e(TAG, " mLocationProviderApi.requestLocationUpdates() " + e);
-            LocationProviderAdapter.newErrorAvailable(
-                    "Failed to request location updates: " + e.toString());
-            assert false;
-        }
-    }
-
-    @Override
-    public void onConnectionSuspended(int cause) {}
-
-    // OnConnectionFailedListener implementation
-    @Override
-    public void onConnectionFailed(ConnectionResult result) {
-        LocationProviderAdapter.newErrorAvailable(
-                "Failed to connect to Google Play Services: " + result.toString());
     }
 
     // LocationProvider implementation
     @Override
     public void start(boolean enableHighAccuracy) {
         ThreadUtils.assertOnUiThread();
-        if (mGoogleApiClient.isConnected()) mGoogleApiClient.disconnect();
 
         mEnablehighAccuracy = enableHighAccuracy;
-        mGoogleApiClient.connect(); // Should return via onConnected().
     }
 
     @Override
     public void stop() {
         ThreadUtils.assertOnUiThread();
-        if (!mGoogleApiClient.isConnected()) return;
-
-        mLocationProviderApi.removeLocationUpdates(mGoogleApiClient, this);
-
-        mGoogleApiClient.disconnect();
     }
 
     @Override
     public boolean isRunning() {
         assert ThreadUtils.runningOnUiThread();
-        if (mGoogleApiClient == null) return false;
-        return mGoogleApiClient.isConnecting() || mGoogleApiClient.isConnected();
-    }
-
-    // LocationListener implementation
-    @Override
-    public void onLocationChanged(Location location) {
-        LocationProviderAdapter.onNewLocationAvailable(location);
+        return false;
     }
 }
--- a/third_party/android_deps/BUILD.gn
+++ b/third_party/android_deps/BUILD.gn
@@ -1028,66 +1028,6 @@ android_aar_prebuilt("google_play_servic
 }
 
 # This is generated, do not edit. Update BuildConfigGenerator.groovy instead.
-android_aar_prebuilt("google_play_services_fido_java") {
-  aar_path = "libs/com_google_android_gms_play_services_fido/play-services-fido-18.1.0.aar"
-  info_path = "libs/com_google_android_gms_play_services_fido/com_google_android_gms_play_services_fido.info"
-  deps = [
-    ":google_play_services_base_java",
-    ":google_play_services_basement_java",
-    ":google_play_services_tasks_java",
-  ]
-
-  # Removing drawables from GMS .aars as they are unused bloat.
-  strip_drawables = true
-}
-
-# This is generated, do not edit. Update BuildConfigGenerator.groovy instead.
-android_aar_prebuilt("google_play_services_iid_java") {
-  aar_path = "libs/com_google_android_gms_play_services_iid/play-services-iid-17.0.0.aar"
-  info_path = "libs/com_google_android_gms_play_services_iid/com_google_android_gms_play_services_iid.info"
-  deps = [
-    ":androidx_collection_collection_java",
-    ":androidx_core_core_java",
-    ":google_play_services_base_java",
-    ":google_play_services_basement_java",
-    ":google_play_services_stats_java",
-    ":google_play_services_tasks_java",
-  ]
-
-  # Removing drawables from GMS .aars as they are unused bloat.
-  strip_drawables = true
-}
-
-# This is generated, do not edit. Update BuildConfigGenerator.groovy instead.
-android_aar_prebuilt("google_play_services_instantapps_java") {
-  aar_path = "libs/com_google_android_gms_play_services_instantapps/play-services-instantapps-17.0.0.aar"
-  info_path = "libs/com_google_android_gms_play_services_instantapps/com_google_android_gms_play_services_instantapps.info"
-  deps = [
-    ":google_play_services_base_java",
-    ":google_play_services_basement_java",
-    ":google_play_services_tasks_java",
-  ]
-
-  # Removing drawables from GMS .aars as they are unused bloat.
-  strip_drawables = true
-}
-
-# This is generated, do not edit. Update BuildConfigGenerator.groovy instead.
-android_aar_prebuilt("google_play_services_location_java") {
-  aar_path = "libs/com_google_android_gms_play_services_location/play-services-location-17.0.0.aar"
-  info_path = "libs/com_google_android_gms_play_services_location/com_google_android_gms_play_services_location.info"
-  deps = [
-    ":google_play_services_base_java",
-    ":google_play_services_basement_java",
-    ":google_play_services_places_placereport_java",
-    ":google_play_services_tasks_java",
-  ]
-
-  # Removing drawables from GMS .aars as they are unused bloat.
-  strip_drawables = true
-}
-
-# This is generated, do not edit. Update BuildConfigGenerator.groovy instead.
 android_aar_prebuilt("google_play_services_tasks_java") {
   aar_path = "libs/com_google_android_gms_play_services_tasks/play-services-tasks-17.0.0.aar"
   info_path = "libs/com_google_android_gms_play_services_tasks/com_google_android_gms_play_services_tasks.info"
--- a/third_party/cacheinvalidation/BUILD.gn
+++ b/third_party/cacheinvalidation/BUILD.gn
@@ -133,7 +133,6 @@ if (is_android) {
     jacoco_never_instrument = true
     deps = [
       ":cacheinvalidation_proto_java",
-      "$google_play_services_package:google_play_services_iid_java",
       "$google_play_services_package:google_play_services_tasks_java",
       "//base:base_java",
       "//third_party/android_protobuf:protobuf_nano_javalib",
--- a/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/external/client/android2/AndroidManifestUpdatedGcm.xml
+++ b/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/external/client/android2/AndroidManifestUpdatedGcm.xml
@@ -27,9 +27,6 @@
     <!-- InstanceID Listener Service -->
     <service android:exported="false"
         android:name="com.google.ipc.invalidation.ticl2.android2.channel.AndroidInstanceIDListenerService">
-        <intent-filter>
-            <action android:name="com.google.android.gms.iid.InstanceID"/>
-        </intent-filter>
     </service>
   </application>
 </manifest>
--- a/chrome/android/java/src/org/chromium/chrome/browser/webauth/Fido2CredentialRequest.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/webauth/Fido2CredentialRequest.java
@@ -13,20 +13,6 @@ import android.os.SystemClock;
 import androidx.annotation.IntDef;
 import androidx.annotation.VisibleForTesting;
 
-import com.google.android.gms.fido.Fido;
-import com.google.android.gms.fido.fido2.Fido2PendingIntent;
-import com.google.android.gms.fido.fido2.Fido2PrivilegedApiClient;
-import com.google.android.gms.fido.fido2.api.common.AuthenticatorAssertionResponse;
-import com.google.android.gms.fido.fido2.api.common.AuthenticatorAttestationResponse;
-import com.google.android.gms.fido.fido2.api.common.AuthenticatorErrorResponse;
-import com.google.android.gms.fido.fido2.api.common.AuthenticatorResponse;
-import com.google.android.gms.fido.fido2.api.common.BrowserPublicKeyCredentialCreationOptions;
-import com.google.android.gms.fido.fido2.api.common.BrowserPublicKeyCredentialRequestOptions;
-import com.google.android.gms.fido.fido2.api.common.PublicKeyCredential;
-import com.google.android.gms.fido.fido2.api.common.PublicKeyCredentialCreationOptions;
-import com.google.android.gms.tasks.OnSuccessListener;
-import com.google.android.gms.tasks.Task;
-
 import org.chromium.base.Callback;
 import org.chromium.base.ContextUtils;
 import org.chromium.base.Log;
@@ -55,7 +41,6 @@ public class Fido2CredentialRequest impl
     private static final String TAG = "Fido2Request";
     private HandlerResponseCallback mCallback;
     private HandlerResponseCallback mIsUserVerifyingPlatformAuthenticatorAvailableCallback;
-    private Fido2PrivilegedApiClient mFido2ApiClient;
     private WebContents mWebContents;
     private ActivityWindowAndroid mWindow;
     private @RequestStatus int mRequestStatus;
@@ -85,58 +70,6 @@ public class Fido2CredentialRequest impl
         mCallback = null;
     }
 
-    // Listens for a Fido2PendingIntent.
-    private OnSuccessListener<Fido2PendingIntent> mIntentListener = new OnSuccessListener<
-            Fido2PendingIntent>() {
-        @Override
-        public void onSuccess(Fido2PendingIntent fido2PendingIntent) {
-            if (!fido2PendingIntent.hasPendingIntent()) {
-                Log.e(TAG, "Didn't receive a pending intent.");
-                returnErrorAndResetCallback(AuthenticatorStatus.UNKNOWN_ERROR);
-                return;
-            }
-
-            if (mWindow == null) {
-                mWindow = ChromeActivity.fromWebContents(mWebContents).getWindowAndroid();
-                if (mWindow == null) {
-                    Log.e(TAG, "Couldn't get ActivityWindowAndroid.");
-                    returnErrorAndResetCallback(AuthenticatorStatus.UNKNOWN_ERROR);
-                    return;
-                }
-            }
-
-            final Activity activity = mWindow.getActivity().get();
-            if (activity == null) {
-                Log.e(TAG, "Null activity.");
-                returnErrorAndResetCallback(AuthenticatorStatus.UNKNOWN_ERROR);
-                return;
-            }
-
-            Callback<Integer> mIntentTrigger = (Integer result) -> {
-                try {
-                    fido2PendingIntent.launchPendingIntent(activity, result);
-                } catch (IntentSender.SendIntentException e) {
-                    Log.e(TAG, "Failed to send Fido2 register request to Google Play Services.");
-                    returnErrorAndResetCallback(AuthenticatorStatus.UNKNOWN_ERROR);
-                }
-            };
-
-            // Record starting time that will be used to establish a timeout that will
-            // be activated when we receive a response that cannot be returned to the
-            // relying party prior to timeout.
-            mStartTimeMs = SystemClock.elapsedRealtime();
-            int requestCode =
-                    mWindow.showCancelableIntent(mIntentTrigger, Fido2CredentialRequest.this, null);
-
-            if (requestCode == WindowAndroid.START_INTENT_FAILURE) {
-                Log.e(TAG, "Failed to send Fido2 request to Google Play Services.");
-                returnErrorAndResetCallback(AuthenticatorStatus.UNKNOWN_ERROR);
-            } else {
-                Log.e(TAG, "Sent a Fido2 request to Google Play Services.");
-            }
-        }
-    };
-
     public void handleMakeCredentialRequest(
             org.chromium.blink.mojom.PublicKeyCredentialCreationOptions options,
             RenderFrameHost frameHost, Origin origin, HandlerResponseCallback callback) {
@@ -150,33 +83,11 @@ public class Fido2CredentialRequest impl
 
         if (!initFido2ApiClient()) {
             Log.e(TAG, "Google Play Services' Fido2PrivilegedApi is not available.");
-            returnErrorAndResetCallback(AuthenticatorStatus.UNKNOWN_ERROR);
             return;
         }
 
         int securityCheck = frameHost.performMakeCredentialWebAuthSecurityChecks(
                 options.relyingParty.id, origin);
-        if (securityCheck != AuthenticatorStatus.SUCCESS) {
-            returnErrorAndResetCallback(securityCheck);
-            return;
-        }
-
-        PublicKeyCredentialCreationOptions credentialCreationOptions;
-        try {
-            credentialCreationOptions = Fido2Helper.toMakeCredentialOptions(options);
-        } catch (NoSuchAlgorithmException e) {
-            returnErrorAndResetCallback(AuthenticatorStatus.ALGORITHM_UNSUPPORTED);
-            return;
-        }
-
-        BrowserPublicKeyCredentialCreationOptions browserRequestOptions =
-                new BrowserPublicKeyCredentialCreationOptions.Builder()
-                        .setPublicKeyCredentialCreationOptions(credentialCreationOptions)
-                        .setOrigin(Uri.parse(convertOriginToString(origin)))
-                        .build();
-
-        Task<Fido2PendingIntent> result = mFido2ApiClient.getRegisterIntent(browserRequestOptions);
-        result.addOnSuccessListener(mIntentListener);
     }
 
     public void handleGetAssertionRequest(PublicKeyCredentialRequestOptions options,
@@ -191,33 +102,11 @@ public class Fido2CredentialRequest impl
 
         if (!initFido2ApiClient()) {
             Log.e(TAG, "Google Play Services' Fido2PrivilegedApi is not available.");
-            returnErrorAndResetCallback(AuthenticatorStatus.UNKNOWN_ERROR);
             return;
         }
 
         int securityCheck =
                 frameHost.performGetAssertionWebAuthSecurityChecks(options.relyingPartyId, origin);
-        if (securityCheck != AuthenticatorStatus.SUCCESS) {
-            returnErrorAndResetCallback(securityCheck);
-            return;
-        }
-
-        if (options.appid != null) {
-            mAppIdExtensionUsed = true;
-        }
-
-        com.google.android.gms.fido.fido2.api.common
-                .PublicKeyCredentialRequestOptions getAssertionOptions;
-        getAssertionOptions = Fido2Helper.toGetAssertionOptions(options);
-
-        BrowserPublicKeyCredentialRequestOptions browserRequestOptions =
-                new BrowserPublicKeyCredentialRequestOptions.Builder()
-                        .setPublicKeyCredentialRequestOptions(getAssertionOptions)
-                        .setOrigin(Uri.parse(convertOriginToString(origin)))
-                        .build();
-
-        Task<Fido2PendingIntent> result = mFido2ApiClient.getSignIntent(browserRequestOptions);
-        result.addOnSuccessListener(mIntentListener);
     }
 
     public void handleIsUserVerifyingPlatformAuthenticatorAvailableRequest(
@@ -237,33 +126,16 @@ public class Fido2CredentialRequest impl
             mIsUserVerifyingPlatformAuthenticatorAvailableCallback = null;
             return;
         }
-
-        Task<Boolean> result =
-                mFido2ApiClient.isUserVerifyingPlatformAuthenticatorAvailable()
-                        .addOnSuccessListener((isUVPAA) -> {
-                            mIsUserVerifyingPlatformAuthenticatorAvailableCallback
-                                    .onIsUserVerifyingPlatformAuthenticatorAvailableResponse(
-                                            isUVPAA);
-                            mIsUserVerifyingPlatformAuthenticatorAvailableCallback = null;
-                        });
     }
 
     /* Initialize the FIDO2 browser API client. */
     private boolean initFido2ApiClient() {
-        if (mFido2ApiClient != null) {
-            return true;
-        }
-
         if (!ExternalAuthUtils.getInstance().canUseGooglePlayServices(
                     new UserRecoverableErrorHandler.Silent())) {
             return false;
         }
 
-        mFido2ApiClient = Fido.getFido2PrivilegedApiClient(ContextUtils.getApplicationContext());
-        if (mFido2ApiClient == null) {
-            return false;
-        }
-        return true;
+        return false;
     }
 
     @VisibleForTesting
@@ -282,13 +154,11 @@ public class Fido2CredentialRequest impl
         if (data == null) {
             Log.e(TAG, "Received a null intent.");
             // The user canceled the request.
-            returnErrorAndResetCallback(AuthenticatorStatus.NOT_ALLOWED_ERROR);
             return;
         }
 
         switch (resultCode) {
             case Activity.RESULT_CANCELED:
-                returnErrorAndResetCallback(AuthenticatorStatus.NOT_ALLOWED_ERROR);
                 break;
             case Activity.RESULT_OK:
                 processIntentResult(data);
@@ -296,62 +166,21 @@ public class Fido2CredentialRequest impl
             default:
                 // Something went wrong.
                 Log.e(TAG, "Failed with result code" + resultCode);
-                returnErrorAndResetCallback(AuthenticatorStatus.UNKNOWN_ERROR);
                 break;
         }
     }
 
     private void processPublicKeyCredential(Intent data) {
-        PublicKeyCredential publicKeyCredential = PublicKeyCredential.deserializeFromBytes(
-                data.getByteArrayExtra(FIDO2_KEY_CREDENTIAL_EXTRA));
-        AuthenticatorResponse response = publicKeyCredential.getResponse();
-        if (response instanceof AuthenticatorErrorResponse) {
-            processErrorResponse((AuthenticatorErrorResponse) response);
-        } else if (response instanceof AuthenticatorAttestationResponse) {
-            try {
-                mCallback.onRegisterResponse(AuthenticatorStatus.SUCCESS,
-                        Fido2Helper.toMakeCredentialResponse(publicKeyCredential));
-                mCallback = null;
-            } catch (NoSuchAlgorithmException e) {
-                returnErrorAndResetCallback(AuthenticatorStatus.ALGORITHM_UNSUPPORTED);
-            }
-        } else if (response instanceof AuthenticatorAssertionResponse) {
-            mCallback.onSignResponse(AuthenticatorStatus.SUCCESS,
-                    Fido2Helper.toGetAssertionResponse(publicKeyCredential, mAppIdExtensionUsed));
-            mCallback = null;
-        }
-    }
-
-    private void processErrorResponse(AuthenticatorErrorResponse errorResponse) {
-        Log.e(TAG,
-                "Google Play Services FIDO2 API returned an error: "
-                        + errorResponse.getErrorMessage());
-        int authenticatorStatus = Fido2Helper.convertError(
-                errorResponse.getErrorCode(), errorResponse.getErrorMessage());
-        returnErrorAndResetCallback(authenticatorStatus);
     }
 
     private void processKeyResponse(Intent data) {
         switch (mRequestStatus) {
             case REGISTER_REQUEST:
                 Log.e(TAG, "Received a register response from Google Play Services FIDO2 API");
-                try {
-                    mCallback.onRegisterResponse(AuthenticatorStatus.SUCCESS,
-                            Fido2Helper.toMakeCredentialResponse(
-                                    AuthenticatorAttestationResponse.deserializeFromBytes(
-                                            data.getByteArrayExtra(
-                                                    Fido.FIDO2_KEY_RESPONSE_EXTRA))));
-                } catch (NoSuchAlgorithmException e) {
-                    returnErrorAndResetCallback(AuthenticatorStatus.ALGORITHM_UNSUPPORTED);
-                }
+                returnErrorAndResetCallback(AuthenticatorStatus.ALGORITHM_UNSUPPORTED);
                 break;
             case SIGN_REQUEST:
                 Log.e(TAG, "Received a sign response from Google Play Services FIDO2 API");
-                mCallback.onSignResponse(AuthenticatorStatus.SUCCESS,
-                        Fido2Helper.toGetAssertionResponse(
-                                AuthenticatorAssertionResponse.deserializeFromBytes(
-                                        data.getByteArrayExtra(Fido.FIDO2_KEY_RESPONSE_EXTRA)),
-                                mAppIdExtensionUsed));
                 break;
         }
         mCallback = null;
@@ -363,17 +192,11 @@ public class Fido2CredentialRequest impl
         // [Attestation/Assertion/Error] Response.
         if (data.hasExtra(FIDO2_KEY_CREDENTIAL_EXTRA)) {
             processPublicKeyCredential(data);
-        } else if (data.hasExtra(Fido.FIDO2_KEY_ERROR_EXTRA)) {
-            processErrorResponse(AuthenticatorErrorResponse.deserializeFromBytes(
-                    data.getByteArrayExtra(Fido.FIDO2_KEY_ERROR_EXTRA)));
-        } else if (data.hasExtra(Fido.FIDO2_KEY_RESPONSE_EXTRA)) {
-            processKeyResponse(data);
         } else {
             // Something went wrong.
             Log.e(TAG,
                     "The response is missing FIDO2_KEY_RESPONSE_EXTRA "
                             + "and FIDO2_KEY_CREDENTIAL_EXTRA.");
-            returnErrorAndResetCallback(AuthenticatorStatus.UNKNOWN_ERROR);
         }
     }
 
--- a/chrome/android/java/src/org/chromium/chrome/browser/webauth/Fido2Helper.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/webauth/Fido2Helper.java
@@ -6,26 +6,6 @@ package org.chromium.chrome.browser.weba
 
 import android.util.Base64;
 
-import com.google.android.gms.fido.common.Transport;
-import com.google.android.gms.fido.fido2.api.common.Attachment;
-import com.google.android.gms.fido.fido2.api.common.AttestationConveyancePreference;
-import com.google.android.gms.fido.fido2.api.common.AuthenticationExtensions;
-import com.google.android.gms.fido.fido2.api.common.AuthenticationExtensionsClientOutputs;
-import com.google.android.gms.fido.fido2.api.common.AuthenticatorAssertionResponse;
-import com.google.android.gms.fido.fido2.api.common.AuthenticatorAttestationResponse;
-import com.google.android.gms.fido.fido2.api.common.AuthenticatorSelectionCriteria;
-import com.google.android.gms.fido.fido2.api.common.ErrorCode;
-import com.google.android.gms.fido.fido2.api.common.FidoAppIdExtension;
-import com.google.android.gms.fido.fido2.api.common.PublicKeyCredential;
-import com.google.android.gms.fido.fido2.api.common.PublicKeyCredentialCreationOptions;
-import com.google.android.gms.fido.fido2.api.common.PublicKeyCredentialDescriptor;
-import com.google.android.gms.fido.fido2.api.common.PublicKeyCredentialParameters;
-import com.google.android.gms.fido.fido2.api.common.PublicKeyCredentialRpEntity;
-import com.google.android.gms.fido.fido2.api.common.PublicKeyCredentialType;
-import com.google.android.gms.fido.fido2.api.common.PublicKeyCredentialUserEntity;
-import com.google.android.gms.fido.fido2.api.common.UserVerificationMethodExtension;
-import com.google.android.gms.fido.fido2.api.common.UvmEntries;
-
 import org.chromium.base.Log;
 import org.chromium.base.annotations.CalledByNative;
 import org.chromium.base.annotations.NativeMethods;
@@ -64,225 +44,6 @@ public final class Fido2Helper {
     static final double MAX_TIMEOUT_SECONDS = 600;
 
     /**
-     * Converts mojo options to gmscore options.
-     * @param options Options passed in from the renderer.
-     * @return Options to be passed to Fido2 API.
-     * @throws NoSuchAlgorithmException
-     */
-    public static PublicKeyCredentialCreationOptions toMakeCredentialOptions(
-            org.chromium.blink.mojom.PublicKeyCredentialCreationOptions options)
-            throws NoSuchAlgorithmException {
-        // Pack incoming options as Fido2's BrowserMakeCredentialOptions.
-        String rpIcon = options.relyingParty.icon != null ? options.relyingParty.icon.url : null;
-        PublicKeyCredentialRpEntity rp = new PublicKeyCredentialRpEntity(
-                options.relyingParty.id, options.relyingParty.name, rpIcon);
-
-        String userIcon = options.user.icon != null ? options.user.icon.url : null;
-        PublicKeyCredentialUserEntity user = new PublicKeyCredentialUserEntity(
-                options.user.id, options.user.name, userIcon, options.user.displayName);
-
-        List<PublicKeyCredentialParameters> parameters = new ArrayList<>();
-        for (org.chromium.blink.mojom.PublicKeyCredentialParameters param :
-                options.publicKeyParameters) {
-            if (param.algorithmIdentifier == ECDSA_COSE_IDENTIFIER
-                    && param.type == org.chromium.blink.mojom.PublicKeyCredentialType.PUBLIC_KEY) {
-                parameters.add(new PublicKeyCredentialParameters(
-                        PublicKeyCredentialType.PUBLIC_KEY.toString(), param.algorithmIdentifier));
-            }
-        }
-
-        // Check that at least one incoming param is supported by the FIDO2 API.
-        if (parameters.size() == 0 && options.publicKeyParameters.length != 0) {
-            Log.e(TAG, "None of the requested parameters are supported.");
-            throw new NoSuchAlgorithmException();
-        }
-
-        List<PublicKeyCredentialDescriptor> excludeCredentials =
-                convertCredentialDescriptor(options.excludeCredentials);
-
-        AuthenticatorSelectionCriteria selection =
-                convertSelectionCriteria(options.authenticatorSelection);
-
-        AttestationConveyancePreference attestationPreference =
-                convertAttestationPreference(options.attestation);
-
-        PublicKeyCredentialCreationOptions credentialCreationOptions =
-                new PublicKeyCredentialCreationOptions.Builder()
-                        .setRp(rp)
-                        .setUser(user)
-                        .setChallenge(options.challenge)
-                        .setParameters(parameters)
-                        .setTimeoutSeconds(adjustTimeout(options.timeout))
-                        .setExcludeList(excludeCredentials)
-                        .setAuthenticatorSelection(selection)
-                        .setAttestationConveyancePreference(attestationPreference)
-                        .build();
-        return credentialCreationOptions;
-    }
-
-    /**
-     * Converts gmscore AuthenticatorAttestationResponse to mojo MakeCredentialAuthenticatorResponse
-     * @param data Response from the Fido2 API.
-     * @return Response to be passed to the renderer.
-     */
-    public static MakeCredentialAuthenticatorResponse toMakeCredentialResponse(
-            AuthenticatorAttestationResponse data) throws NoSuchAlgorithmException {
-        MakeCredentialAuthenticatorResponse response = new MakeCredentialAuthenticatorResponse();
-        CommonCredentialInfo info = new CommonCredentialInfo();
-
-        response.attestationObject = data.getAttestationObject();
-        AttestationObjectParts parts = new AttestationObjectParts();
-        if (!Fido2HelperJni.get().parseAttestationObject(response.attestationObject, parts)) {
-            // A failure to parse the attestation object is fatal to the request
-            // on desktop and so the same behavior is used here.
-            throw new NoSuchAlgorithmException();
-        }
-        response.publicKeyAlgo = parts.coseAlgorithm;
-        info.authenticatorData = parts.authenticatorData;
-        response.publicKeyDer = parts.spki;
-
-        // An empty transports array indicates that we don't have any
-        // information about the available transports.
-        response.transports = new int[] {};
-
-        info.id = encodeId(data.getKeyHandle());
-        info.rawId = data.getKeyHandle();
-        info.clientDataJson = data.getClientDataJSON();
-        response.info = info;
-        return response;
-    }
-
-    public static MakeCredentialAuthenticatorResponse toMakeCredentialResponse(
-            PublicKeyCredential data) throws NoSuchAlgorithmException {
-        MakeCredentialAuthenticatorResponse response =
-                toMakeCredentialResponse((AuthenticatorAttestationResponse) data.getResponse());
-        return response;
-    }
-
-    /**
-     * Converts mojo options to gmscore options.
-     * @param options Options passed in from the renderer.
-     * @return Options to be passed to Fido2 API.
-     */
-    public static com.google.android.gms.fido.fido2.api.common.PublicKeyCredentialRequestOptions
-    toGetAssertionOptions(PublicKeyCredentialRequestOptions options) {
-        List<PublicKeyCredentialDescriptor> allowCredentials =
-                convertCredentialDescriptor(options.allowCredentials);
-
-        FidoAppIdExtension fidoAppIdExtension =
-                (options.appid != null) ? new FidoAppIdExtension(options.appid) : null;
-        UserVerificationMethodExtension userVerificationMethodExtension =
-                new UserVerificationMethodExtension(options.userVerificationMethods);
-        AuthenticationExtensions authenticationExtensions =
-                new AuthenticationExtensions.Builder()
-                        .setFido2Extension(fidoAppIdExtension)
-                        .setUserVerificationMethodExtension(userVerificationMethodExtension)
-                        .build();
-
-        // Pack options as Fido2's BrowserPublicKeyCredentialRequestOptions.
-        com.google.android.gms.fido.fido2.api.common
-                .PublicKeyCredentialRequestOptions credentialRequestOptions =
-                new com.google.android.gms.fido.fido2.api.common.PublicKeyCredentialRequestOptions
-                        .Builder()
-                        .setChallenge(options.challenge)
-                        .setTimeoutSeconds(adjustTimeout(options.timeout))
-                        .setRpId(options.relyingPartyId)
-                        .setAllowList(allowCredentials)
-                        /* TODO add back UserVerificationRequirement when the FIDO2 API supports it
-                         */
-                        .setAuthenticationExtensions(authenticationExtensions)
-                        .build();
-        return credentialRequestOptions;
-    }
-
-    /**
-     * Helper method that creates GetAssertionAuthenticatorResponse objects.
-     */
-    public static GetAssertionAuthenticatorResponse toGetAssertionResponse(
-            AuthenticatorAssertionResponse data, boolean appIdExtensionUsed) {
-        GetAssertionAuthenticatorResponse response = new GetAssertionAuthenticatorResponse();
-        CommonCredentialInfo info = new CommonCredentialInfo();
-        response.signature = data.getSignature();
-        response.echoAppidExtension = appIdExtensionUsed;
-        info.authenticatorData = data.getAuthenticatorData();
-        info.id = encodeId(data.getKeyHandle());
-        info.rawId = data.getKeyHandle();
-        info.clientDataJson = data.getClientDataJSON();
-        response.info = info;
-        return response;
-    }
-
-    public static GetAssertionAuthenticatorResponse toGetAssertionResponse(
-            PublicKeyCredential data, boolean appIdExtensionUsed) {
-        GetAssertionAuthenticatorResponse response = toGetAssertionResponse(
-                (AuthenticatorAssertionResponse) data.getResponse(), appIdExtensionUsed);
-        AuthenticationExtensionsClientOutputs extensionsClientOutputs =
-                data.getClientExtensionResults();
-
-        if (extensionsClientOutputs != null && extensionsClientOutputs.getUvmEntries() != null) {
-            response.echoUserVerificationMethods = true;
-            response.userVerificationMethods =
-                    getUserVerificationMethods(extensionsClientOutputs.getUvmEntries());
-        }
-        return response;
-    }
-
-    /**
-     * Helper method to convert AuthenticatorErrorResponse errors.
-     * @param errorCode
-     * @return error code corresponding to an AuthenticatorStatus.
-     */
-    public static int convertError(ErrorCode errorCode, String errorMsg) {
-        // TODO(b/113347251): Use specific error codes instead of strings when GmsCore Fido2
-        // provides them.
-        switch (errorCode) {
-            case SECURITY_ERR:
-                // AppId or rpID fails validation.
-                return AuthenticatorStatus.INVALID_DOMAIN;
-            case TIMEOUT_ERR:
-                return AuthenticatorStatus.NOT_ALLOWED_ERROR;
-            case ENCODING_ERR:
-                // Error encoding results (after user consent).
-                return AuthenticatorStatus.UNKNOWN_ERROR;
-            case NOT_ALLOWED_ERR:
-                // The implementation doesn't support resident keys.
-                if (errorMsg != null
-                        && (errorMsg.equals(NON_EMPTY_ALLOWLIST_ERROR_MSG)
-                                || errorMsg.equals(NON_VALID_ALLOWED_CREDENTIALS_ERROR_MSG))) {
-                    return AuthenticatorStatus.EMPTY_ALLOW_CREDENTIALS;
-                }
-                // The request is not allowed, possibly because the user denied permission.
-                return AuthenticatorStatus.NOT_ALLOWED_ERROR;
-            case DATA_ERR:
-            // Incoming requests were malformed/inadequate. Fallthrough.
-            case NOT_SUPPORTED_ERR:
-                // Request parameters were not supported.
-                return AuthenticatorStatus.ANDROID_NOT_SUPPORTED_ERROR;
-            case CONSTRAINT_ERR:
-                if (errorMsg != null && errorMsg.equals(NO_SCREENLOCK_ERROR_MSG)) {
-                    return AuthenticatorStatus.USER_VERIFICATION_UNSUPPORTED;
-                } else {
-                    // The user attempted to use a credential that was already registered.
-                    return AuthenticatorStatus.CREDENTIAL_EXCLUDED;
-                }
-            case INVALID_STATE_ERR:
-                if (errorMsg != null && errorMsg.equals(CREDENTIAL_EXISTS_ERROR_MSG)) {
-                    return AuthenticatorStatus.CREDENTIAL_EXCLUDED;
-                }
-            // else fallthrough.
-            case UNKNOWN_ERR:
-                if (errorMsg != null && errorMsg.equals(LOW_LEVEL_ERROR_MSG)) {
-                    // The error message returned from GmsCore when the user attempted to use a
-                    // credential that is not registered.
-                    return AuthenticatorStatus.CREDENTIAL_NOT_RECOGNIZED;
-                }
-            // fall through
-            default:
-                return AuthenticatorStatus.UNKNOWN_ERROR;
-        }
-    }
-
-    /**
      * Base64 encodes the raw id.
      * @param keyHandle the raw id (key handle of the credential).
      * @return Base64-encoded id.
@@ -293,102 +54,6 @@ public final class Fido2Helper {
     }
 
     /**
-     * Parses uvmEntries into userVerificationMethods
-     * @param uvmEntries defined in gmscore.
-     * @return userVerificationMethods defined in authenticato.mojom.
-     */
-    private static UvmEntry[] getUserVerificationMethods(UvmEntries uvmEntries) {
-        List<com.google.android.gms.fido.fido2.api.common.UvmEntry> uvmEntryList =
-                uvmEntries.getUvmEntryList();
-        UvmEntry[] userVerificationMethods = new UvmEntry[uvmEntryList.size()];
-        for (int i = 0; i < uvmEntryList.size(); i++) {
-            UvmEntry uvmEntry = new UvmEntry();
-            uvmEntry.userVerificationMethod = uvmEntryList.get(i).getUserVerificationMethod();
-            uvmEntry.keyProtectionType = uvmEntryList.get(i).getKeyProtectionType();
-            uvmEntry.matcherProtectionType = uvmEntryList.get(i).getMatcherProtectionType();
-            userVerificationMethods[i] = uvmEntry;
-        }
-        return userVerificationMethods;
-    }
-
-    private static List<PublicKeyCredentialDescriptor> convertCredentialDescriptor(
-            org.chromium.blink.mojom.PublicKeyCredentialDescriptor[] mojoDescriptors) {
-        if (mojoDescriptors == null) {
-            return null;
-        }
-
-        List<PublicKeyCredentialDescriptor> descriptors = new ArrayList<>();
-        for (org.chromium.blink.mojom.PublicKeyCredentialDescriptor descriptor : mojoDescriptors) {
-            descriptors.add(
-                    new PublicKeyCredentialDescriptor(PublicKeyCredentialType.PUBLIC_KEY.toString(),
-                            descriptor.id, toTransportList(descriptor.transports)));
-        }
-        return descriptors;
-    }
-
-    private static AuthenticatorSelectionCriteria convertSelectionCriteria(
-            org.chromium.blink.mojom.AuthenticatorSelectionCriteria mojoSelection) {
-        AuthenticatorSelectionCriteria selection = null;
-        if (mojoSelection != null) {
-            /* Sets UserVerificationRequirement and RequireResidentKey to default until the FIDO2
-             * API supports the other options. */
-            selection =
-                    new AuthenticatorSelectionCriteria.Builder()
-                            .setAttachment(convertAttachment(mojoSelection.authenticatorAttachment))
-                            .build();
-        }
-        return selection;
-    }
-
-    private static List<Transport> toTransportList(int[] mojoTransports) {
-        List<Transport> fidoTransports = new ArrayList<>();
-        for (int transport : mojoTransports) {
-            fidoTransports.add(convertTransport(transport));
-        }
-        return fidoTransports;
-    }
-
-    private static Transport convertTransport(int transport) {
-        switch (transport) {
-            case AuthenticatorTransport.USB:
-                return Transport.USB;
-            case AuthenticatorTransport.NFC:
-                return Transport.NFC;
-            case AuthenticatorTransport.BLE:
-                return Transport.BLUETOOTH_LOW_ENERGY;
-            case AuthenticatorTransport.INTERNAL:
-                return Transport.INTERNAL;
-            default:
-                return Transport.USB;
-        }
-    }
-
-    private static Attachment convertAttachment(int attachment) {
-        if (attachment == AuthenticatorAttachment.NO_PREFERENCE) {
-            return null;
-        } else if (attachment == AuthenticatorAttachment.CROSS_PLATFORM) {
-            return Attachment.CROSS_PLATFORM;
-        } else {
-            return Attachment.PLATFORM;
-        }
-    }
-
-    private static AttestationConveyancePreference convertAttestationPreference(int preference) {
-        switch (preference) {
-            case org.chromium.blink.mojom.AttestationConveyancePreference.NONE:
-                return AttestationConveyancePreference.NONE;
-            case org.chromium.blink.mojom.AttestationConveyancePreference.INDIRECT:
-                return AttestationConveyancePreference.INDIRECT;
-            case org.chromium.blink.mojom.AttestationConveyancePreference.DIRECT:
-                return AttestationConveyancePreference.DIRECT;
-            case org.chromium.blink.mojom.AttestationConveyancePreference.ENTERPRISE:
-                return AttestationConveyancePreference.NONE;
-            default:
-                return AttestationConveyancePreference.NONE;
-        }
-    }
-
-    /**
      * Adjusts a timeout between a reasonable minimum and maximum.
      *
      * @param timeout The unadjusted timeout as specified by the website. May be null.
--- a/chrome/android/java/src/org/chromium/chrome/browser/externalnav/ExternalNavigationDelegateImpl.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/externalnav/ExternalNavigationDelegateImpl.java
@@ -282,12 +282,6 @@ public class ExternalNavigationDelegateI
 
     @Override
     public void maybeAdjustInstantAppExtras(Intent intent, boolean isIntentToInstantApp) {
-        if (isIntentToInstantApp) {
-            intent.putExtra(InstantAppsHandler.IS_GOOGLE_SEARCH_REFERRER, true);
-        } else {
-            // Make sure this extra is not sent unless we've done the verification.
-            intent.removeExtra(InstantAppsHandler.IS_GOOGLE_SEARCH_REFERRER);
-        }
     }
 
     @Override
--- a/chrome/android/features/cablev2_authenticator/BUILD.gn
+++ b/chrome/android/features/cablev2_authenticator/BUILD.gn
@@ -15,7 +15,6 @@ android_library("java") {
 
   deps = [
     "$google_play_services_package:google_play_services_base_java",
-    "$google_play_services_package:google_play_services_fido_java",
     "$google_play_services_package:google_play_services_tasks_java",
     "$google_play_services_package:google_play_services_vision_common_java",
     "$google_play_services_package:google_play_services_vision_java",
--- a/base/android/java/src/org/chromium/base/IntentUtils.java
+++ b/base/android/java/src/org/chromium/base/IntentUtils.java
@@ -36,9 +36,6 @@ public class IntentUtils {
     public static final String ANDROID_APP_REFERRER_SCHEME = "android-app";
 
     // Instant Apps system resolver activity on N-MR1+.
-    @VisibleForTesting
-    public static final String EPHEMERAL_INSTALLER_CLASS =
-            "com.google.android.gms.instantapps.routing.EphemeralInstallerActivity";
 
     /**
      * Whether the given ResolveInfo object refers to Instant Apps as a launcher.
@@ -50,7 +47,7 @@ public class IntentUtils {
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
             return info.isInstantAppAvailable;
         } else if (info.activityInfo != null) {
-            return EPHEMERAL_INSTALLER_CLASS.equals(info.activityInfo.name);
+            return false;
         }
 
         return false;
--- a/services/BUILD.gn
+++ b/services/BUILD.gn
@@ -105,7 +105,6 @@ if (is_android) {
     deps = [
       "$google_play_services_package:google_play_services_base_java",
       "$google_play_services_package:google_play_services_basement_java",
-      "$google_play_services_package:google_play_services_location_java",
       "$google_play_services_package:google_play_services_vision_common_java",
       "$google_play_services_package:google_play_services_vision_java",
       "//base:base_java",
--- a/components/gcm_driver/instance_id/android/javatests/src/org/chromium/components/gcm_driver/instance_id/FakeInstanceIDWithSubtype.java
+++ b/components/gcm_driver/instance_id/android/javatests/src/org/chromium/components/gcm_driver/instance_id/FakeInstanceIDWithSubtype.java
@@ -8,8 +8,6 @@ import android.os.Bundle;
 import android.os.Looper;
 import android.util.Pair;
 
-import com.google.android.gms.iid.InstanceID;
-
 import org.chromium.base.annotations.CalledByNative;
 import org.chromium.base.annotations.JNINamespace;
 
@@ -100,7 +98,7 @@ public class FakeInstanceIDWithSubtype e
         // SharedPreferences. Since we can't override those static methods to simulate the strict
         // mode violation in tests, check the thread here (which is only called from getInstance).
         if (Looper.getMainLooper() == Looper.myLooper())
-            throw new AssertionError(InstanceID.ERROR_MAIN_THREAD);
+            throw new AssertionError();
     }
 
     @Override
@@ -113,7 +111,7 @@ public class FakeInstanceIDWithSubtype e
         // InstanceID.getId sometimes triggers a strict mode violation if it's called on the main
         // thread, by reading from SharedPreferences.
         if (Looper.getMainLooper() == Looper.myLooper())
-            throw new AssertionError(InstanceID.ERROR_MAIN_THREAD);
+            throw new AssertionError();
 
         if (mId == null) {
             mCreationTime = System.currentTimeMillis();
@@ -127,7 +125,7 @@ public class FakeInstanceIDWithSubtype e
         // InstanceID.getCreationTime sometimes triggers a strict mode violation if it's called on
         // the main thread, by reading from SharedPreferences.
         if (Looper.getMainLooper() == Looper.myLooper())
-            throw new AssertionError(InstanceID.ERROR_MAIN_THREAD);
+            throw new AssertionError();
 
         return mCreationTime;
     }
@@ -142,7 +140,7 @@ public class FakeInstanceIDWithSubtype e
             throws IOException {
         // InstanceID.getToken enforces this.
         if (Looper.getMainLooper() == Looper.myLooper()) {
-            throw new IOException(InstanceID.ERROR_MAIN_THREAD);
+            throw new IOException();
         }
 
         String key = getSubtype() + ',' + authorizedEntity + ',' + scope;
@@ -159,7 +157,7 @@ public class FakeInstanceIDWithSubtype e
     public void deleteToken(String authorizedEntity, String scope) throws IOException {
         // InstanceID.deleteToken enforces this.
         if (Looper.getMainLooper() == Looper.myLooper()) {
-            throw new IOException(InstanceID.ERROR_MAIN_THREAD);
+            throw new IOException();
         }
 
         String key = getSubtype() + ',' + authorizedEntity + ',' + scope;
@@ -175,7 +173,7 @@ public class FakeInstanceIDWithSubtype e
 
             // InstanceID.deleteInstanceID calls InstanceID.deleteToken which enforces this.
             if (Looper.getMainLooper() == Looper.myLooper()) {
-                throw new IOException(InstanceID.ERROR_MAIN_THREAD);
+                throw new IOException();
             }
 
             mTokens.clear();
--- a/chrome/android/features/cablev2_authenticator/java/src/org/chromium/chrome/browser/webauth/authenticator/CableAuthenticator.java
+++ b/chrome/android/features/cablev2_authenticator/java/src/org/chromium/chrome/browser/webauth/authenticator/CableAuthenticator.java
@@ -12,25 +12,6 @@ import android.content.IntentSender;
 import android.net.Uri;
 import android.os.Bundle;
 
-import com.google.android.gms.fido.Fido;
-import com.google.android.gms.fido.common.Transport;
-import com.google.android.gms.fido.fido2.Fido2PrivilegedApiClient;
-import com.google.android.gms.fido.fido2.api.common.Attachment;
-import com.google.android.gms.fido.fido2.api.common.AttestationConveyancePreference;
-import com.google.android.gms.fido.fido2.api.common.AuthenticatorAssertionResponse;
-import com.google.android.gms.fido.fido2.api.common.AuthenticatorAttestationResponse;
-import com.google.android.gms.fido.fido2.api.common.AuthenticatorErrorResponse;
-import com.google.android.gms.fido.fido2.api.common.AuthenticatorSelectionCriteria;
-import com.google.android.gms.fido.fido2.api.common.BrowserPublicKeyCredentialCreationOptions;
-import com.google.android.gms.fido.fido2.api.common.BrowserPublicKeyCredentialRequestOptions;
-import com.google.android.gms.fido.fido2.api.common.PublicKeyCredential;
-import com.google.android.gms.fido.fido2.api.common.PublicKeyCredentialCreationOptions;
-import com.google.android.gms.fido.fido2.api.common.PublicKeyCredentialDescriptor;
-import com.google.android.gms.fido.fido2.api.common.PublicKeyCredentialParameters;
-import com.google.android.gms.fido.fido2.api.common.PublicKeyCredentialRequestOptions;
-import com.google.android.gms.fido.fido2.api.common.PublicKeyCredentialRpEntity;
-import com.google.android.gms.fido.fido2.api.common.PublicKeyCredentialType;
-import com.google.android.gms.fido.fido2.api.common.PublicKeyCredentialUserEntity;
 import com.google.android.gms.tasks.Task;
 
 import org.chromium.base.Log;
@@ -99,69 +80,8 @@ class CableAuthenticator {
         // TODO: handle concurrent requests
         assert mClientAddress == 0;
         mClientAddress = clientAddress;
-        Fido2PrivilegedApiClient client = Fido.getFido2PrivilegedApiClient(mContext);
-        if (client == null) {
-            Log.i(TAG, "getFido2PrivilegedApiClient failed");
-            return;
-        }
-        Log.i(TAG, "have fido client");
-
-        List<PublicKeyCredentialParameters> parameters = new ArrayList<>();
-        for (int i = 0; i < algorithms.length; i++) {
-            try {
-                parameters.add(new PublicKeyCredentialParameters(
-                        PublicKeyCredentialType.PUBLIC_KEY.toString(), algorithms[i]));
-            } catch (IllegalArgumentException e) {
-                // The FIDO API will throw IllegalArgumentException for unrecognised algorithms.
-                // Since an authenticator ignores unknown algorithms, this exception just needs to
-                // be caught and ignored.
-            }
-        }
-        // The GmsCore FIDO2 API does not actually support resident keys yet.
-        AuthenticatorSelectionCriteria selection = new AuthenticatorSelectionCriteria.Builder()
-                                                           .setAttachment(Attachment.PLATFORM)
-                                                           .build();
-        List<PublicKeyCredentialDescriptor> excludeCredentials =
-                new ArrayList<PublicKeyCredentialDescriptor>();
-        for (int i = 0; i < excludedCredentialIds.length; i++) {
-            excludeCredentials.add(
-                    new PublicKeyCredentialDescriptor(PublicKeyCredentialType.PUBLIC_KEY.toString(),
-                            excludedCredentialIds[i], new ArrayList<Transport>()));
-        }
-        byte[] dummy = new byte[32];
-        PublicKeyCredentialCreationOptions credentialCreationOptions =
-                new PublicKeyCredentialCreationOptions.Builder()
-                        .setRp(new PublicKeyCredentialRpEntity(rpId, "", ""))
-                        .setUser(new PublicKeyCredentialUserEntity(userId, "", null, ""))
-                        .setChallenge(challenge)
-                        .setParameters(parameters)
-                        .setTimeoutSeconds(TIMEOUT_SECONDS)
-                        .setExcludeList(excludeCredentials)
-                        .setAuthenticatorSelection(selection)
-                        .setAttestationConveyancePreference(AttestationConveyancePreference.NONE)
-                        .build();
-        BrowserPublicKeyCredentialCreationOptions browserRequestOptions =
-                new BrowserPublicKeyCredentialCreationOptions.Builder()
-                        .setPublicKeyCredentialCreationOptions(credentialCreationOptions)
-                        .setOrigin(Uri.parse(origin))
-                        .build();
-        Task<PendingIntent> result = client.getRegisterPendingIntent(browserRequestOptions);
-        result.addOnSuccessListener(pedingIntent -> {
-                  Log.i(TAG, "got pending");
-                  try {
-                      mUi.startIntentSenderForResult(pedingIntent.getIntentSender(),
-                              REGISTER_REQUEST_CODE,
-                              null, // fillInIntent,
-                              0, // flagsMask,
-                              0, // flagsValue,
-                              0, // extraFlags,
-                              Bundle.EMPTY);
-                  } catch (IntentSender.SendIntentException e) {
-                      Log.e(TAG, "intent failure");
-                  }
-              }).addOnFailureListener(e -> { Log.e(TAG, "intent failure" + e); });
-
-        Log.i(TAG, "op done");
+        Log.i(TAG, "getFido2PrivilegedApiClient failed");
+        return;
     }
 
     public void getAssertion(long clientAddress, String origin, String rpId, byte[] challenge,
@@ -170,54 +90,8 @@ class CableAuthenticator {
         assert mClientAddress == 0;
         mClientAddress = clientAddress;
 
-        Fido2PrivilegedApiClient client = Fido.getFido2PrivilegedApiClient(mContext);
-        if (client == null) {
-            Log.i(TAG, "getFido2PrivilegedApiClient failed");
-            return;
-        }
-        Log.i(TAG, "have fido client");
-
-        List<PublicKeyCredentialDescriptor> allowCredentials =
-                new ArrayList<PublicKeyCredentialDescriptor>();
-        ArrayList<Transport> transports = new ArrayList<Transport>();
-        transports.add(Transport.INTERNAL);
-        for (int i = 0; i < allowedCredentialIds.length; i++) {
-            allowCredentials.add(
-                    new PublicKeyCredentialDescriptor(PublicKeyCredentialType.PUBLIC_KEY.toString(),
-                            allowedCredentialIds[i], transports));
-        }
-
-        PublicKeyCredentialRequestOptions credentialRequestOptions =
-                new PublicKeyCredentialRequestOptions.Builder()
-                        .setAllowList(allowCredentials)
-                        .setChallenge(challenge)
-                        .setRpId(rpId)
-                        .setTimeoutSeconds(TIMEOUT_SECONDS)
-                        .build();
-
-        BrowserPublicKeyCredentialRequestOptions browserRequestOptions =
-                new BrowserPublicKeyCredentialRequestOptions.Builder()
-                        .setPublicKeyCredentialRequestOptions(credentialRequestOptions)
-                        .setOrigin(Uri.parse(origin))
-                        .build();
-
-        Task<PendingIntent> result = client.getSignPendingIntent(browserRequestOptions);
-        result.addOnSuccessListener(pedingIntent -> {
-                  Log.i(TAG, "got pending");
-                  try {
-                      mUi.startIntentSenderForResult(pedingIntent.getIntentSender(),
-                              SIGN_REQUEST_CODE,
-                              null, // fillInIntent,
-                              0, // flagsMask,
-                              0, // flagsValue,
-                              0, // extraFlags,
-                              Bundle.EMPTY);
-                  } catch (IntentSender.SendIntentException e) {
-                      Log.e(TAG, "intent failure");
-                  }
-              }).addOnFailureListener(e -> { Log.e(TAG, "intent failure" + e); });
-
-        Log.i(TAG, "op done");
+        Log.i(TAG, "getFido2PrivilegedApiClient failed");
+        return;
     }
 
     public void onActivityResult(int requestCode, int resultCode, Intent data) {
@@ -254,48 +128,7 @@ class CableAuthenticator {
             return false;
         }
         Log.e(TAG, "OK.");
-
-        if (data.hasExtra(Fido.FIDO2_KEY_ERROR_EXTRA)) {
-            Log.e(TAG, "error extra");
-            AuthenticatorErrorResponse error = AuthenticatorErrorResponse.deserializeFromBytes(
-                    data.getByteArrayExtra(Fido.FIDO2_KEY_ERROR_EXTRA));
-            Log.i(TAG,
-                    "error response: " + error.getErrorMessage() + " "
-                            + String.valueOf(error.getErrorCodeAsInt()));
-
-            // ErrorCode represents DOMErrors not CTAP status codes.
-            // TODO: figure out translation of the remaining codes
-            int ctap_status;
-            switch (error.getErrorCode()) {
-                case NOT_ALLOWED_ERR:
-                    ctap_status = CTAP2_ERR_OPERATION_DENIED;
-                    break;
-                default:
-                    ctap_status = CTAP2_ERR_OTHER;
-                    break;
-            }
-            mBleHandler.onAuthenticatorAttestationResponse(
-                    mClientAddress, CTAP2_ERR_OTHER, null, null);
-            return false;
-        }
-
-        if (!data.hasExtra(Fido.FIDO2_KEY_RESPONSE_EXTRA)
-                || !data.hasExtra(Fido.FIDO2_KEY_CREDENTIAL_EXTRA)) {
-            Log.e(TAG, "Missing FIDO2_KEY_RESPONSE_EXTRA or FIDO2_KEY_CREDENTIAL_EXTRA");
-            mBleHandler.onAuthenticatorAttestationResponse(
-                    mClientAddress, CTAP2_ERR_OTHER, null, null);
-            return false;
-        }
-
-        Log.e(TAG, "cred extra");
-        PublicKeyCredential unusedPublicKeyCredential = PublicKeyCredential.deserializeFromBytes(
-                data.getByteArrayExtra(Fido.FIDO2_KEY_CREDENTIAL_EXTRA));
-        AuthenticatorAttestationResponse response =
-                AuthenticatorAttestationResponse.deserializeFromBytes(
-                        data.getByteArrayExtra(Fido.FIDO2_KEY_RESPONSE_EXTRA));
-        mBleHandler.onAuthenticatorAttestationResponse(mClientAddress, CTAP2_OK,
-                response.getClientDataJSON(), response.getAttestationObject());
-        return true;
+        return false;
     }
 
     public boolean onSignResponse(int resultCode, Intent data) {
@@ -306,49 +139,7 @@ class CableAuthenticator {
             return false;
         }
         Log.e(TAG, "OK.");
-
-        if (data.hasExtra(Fido.FIDO2_KEY_ERROR_EXTRA)) {
-            Log.e(TAG, "error extra");
-            AuthenticatorErrorResponse error = AuthenticatorErrorResponse.deserializeFromBytes(
-                    data.getByteArrayExtra(Fido.FIDO2_KEY_ERROR_EXTRA));
-            Log.i(TAG,
-                    "error response: " + error.getErrorMessage() + " "
-                            + String.valueOf(error.getErrorCodeAsInt()));
-
-            // ErrorCode represents DOMErrors not CTAP status codes.
-            // TODO: figure out translation of the remaining codes
-            int ctap_status;
-            switch (error.getErrorCode()) {
-                case NOT_ALLOWED_ERR:
-                    ctap_status = CTAP2_ERR_OPERATION_DENIED;
-                    break;
-                default:
-                    ctap_status = CTAP2_ERR_OTHER;
-                    break;
-            }
-            mBleHandler.onAuthenticatorAssertionResponse(
-                    mClientAddress, ctap_status, null, null, null, null);
-            return false;
-        }
-
-        if (!data.hasExtra(Fido.FIDO2_KEY_RESPONSE_EXTRA)
-                || !data.hasExtra(Fido.FIDO2_KEY_CREDENTIAL_EXTRA)) {
-            Log.e(TAG, "Missing FIDO2_KEY_RESPONSE_EXTRA or FIDO2_KEY_CREDENTIAL_EXTRA");
-            mBleHandler.onAuthenticatorAssertionResponse(
-                    mClientAddress, CTAP2_ERR_OTHER, null, null, null, null);
-            return false;
-        }
-
-        Log.e(TAG, "cred extra");
-        PublicKeyCredential unusedPublicKeyCredential = PublicKeyCredential.deserializeFromBytes(
-                data.getByteArrayExtra(Fido.FIDO2_KEY_CREDENTIAL_EXTRA));
-        AuthenticatorAssertionResponse response =
-                AuthenticatorAssertionResponse.deserializeFromBytes(
-                        data.getByteArrayExtra(Fido.FIDO2_KEY_RESPONSE_EXTRA));
-        mBleHandler.onAuthenticatorAssertionResponse(mClientAddress, CTAP2_OK,
-                response.getClientDataJSON(), response.getKeyHandle(),
-                response.getAuthenticatorData(), response.getSignature());
-        return true;
+        return false;
     }
 
     public void onQRCode(String value) {
