---
 chrome/browser/apps/platform_apps/api/music_manager_private/device_id_android.cc                   |  188 ++++++++
 chrome/browser/chrome_content_browser_client.cc                                                    |    2 
 chrome/browser/devtools/chrome_devtools_manager_delegate.h                                         |    2 
 chrome/browser/extensions/api/downloads/downloads_api.cc                                           |    1 
 chrome/browser/extensions/api/enterprise_reporting_private/chrome_desktop_report_request_helper.cc |    5 
 chrome/browser/extensions/api/messaging/native_messaging_host_manifest.cc                          |   13 
 chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc          |   28 -
 chrome/browser/extensions/api/tabs/windows_event_router.cc                                         |    2 
 chrome/browser/media/router/media_router.h                                                         |    4 
 chrome/browser/media/router/media_router_base.cc                                                   |    2 
 chrome/browser/media/router/media_router_base.h                                                    |    4 
 chrome/browser/media/router/media_router_feature.cc                                                |    7 
 chrome/browser/media/router/media_router_feature.h                                                 |    4 
 chrome/browser/media/webrtc/media_capture_devices_dispatcher.cc                                    |    9 
 chrome/browser/profiles/profile.cc                                                                 |    6 
 chrome/browser/profiles/profile.h                                                                  |    4 
 chrome/browser/profiles/profile_window.h                                                           |    3 
 chrome/browser/profiles/profiles_state.cc                                                          |    4 
 chrome/browser/profiles/profiles_state.h                                                           |    2 
 chrome/browser/search/instant_service.h                                                            |    2 
 chrome/browser/search/instant_service_factory.h                                                    |    2 
 chrome/browser/ui/browser.h                                                                        |    4 
 chrome/browser/ui/browser_commands.cc                                                              |    1 
 chrome/browser/ui/browser_navigator_params.cc                                                      |    2 
 chrome/browser/ui/browser_navigator_params.h                                                       |    6 
 chrome/browser/ui/browser_window.h                                                                 |    2 
 chrome/browser/ui/signin_view_controller.h                                                         |    4 
 chrome/browser/ui/tabs/tab_strip_model.h                                                           |    4 
 chrome/browser/web_applications/components/web_app_shortcut_android.cc                             |  116 +++++
 chrome/browser/web_applications/components/web_app_shortcut_android.h                              |   62 ++
 chrome/common/chrome_features.cc                                                                   |    4 
 chrome/common/chrome_features.h                                                                    |    4 
 chrome/common/chrome_paths.cc                                                                      |    2 
 chrome/common/chrome_paths.h                                                                       |    2 
 chrome/common/pref_names.cc                                                                        |    4 
 chrome/common/pref_names.h                                                                         |    4 
 extensions/browser/api/device_permissions_prompt.cc                                                |    2 
 extensions/browser/api/hid/hid_device_manager.cc                                                   |    2 
 extensions/browser/api/system_cpu/cpu_info_provider_android.cc                                     |   77 +++
 extensions/browser/guest_view/web_view/web_view_guest.cc                                           |    1 
 ui/android/window_android.h                                                                        |    7 
 ui/base/dragdrop/os_exchange_data.h                                                                |    8 
 ui/base/dragdrop/os_exchange_data_provider_android.cc                                              |  220 ++++++++++
 ui/base/dragdrop/os_exchange_data_provider_android.h                                               |  101 ++++
 ui/base/dragdrop/os_exchange_data_provider_factory.cc                                              |    4 
 ui/events/event.h                                                                                  |    1 
 ui/views/controls/menu/menu_controller.h                                                           |    1 
 ui/views/controls/menu/menu_host.cc                                                                |    8 
 ui/views/controls/menu/menu_host.h                                                                 |    2 
 ui/views/controls/webview/unhandled_keyboard_event_handler_default.cc                              |    2 
 50 files changed, 816 insertions(+), 135 deletions(-)

--- /dev/null
+++ b/chrome/browser/web_applications/components/web_app_shortcut_android.cc
@@ -0,0 +1,116 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/web_applications/components/web_app_shortcut_android.h"
+
+#include <fcntl.h>
+
+#include "base/base_paths.h"
+#include "base/environment.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/files/scoped_temp_dir.h"
+#include "base/i18n/file_util_icu.h"
+#include "base/nix/xdg_util.h"
+#include "base/path_service.h"
+#include "base/posix/eintr_wrapper.h"
+#include "base/process/kill.h"
+#include "base/process/launch.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "chrome/browser/shell_integration.h"
+#include "chrome/browser/web_applications/components/web_app_helpers.h"
+#include "chrome/browser/web_applications/components/web_app_shortcut.h"
+#include "chrome/common/buildflags.h"
+#include "chrome/common/chrome_constants.h"
+
+namespace {
+
+}  // namespace
+
+namespace web_app {
+
+base::FilePath GetAppShortcutFilename(const base::FilePath& profile_path,
+                                      const std::string& app_id) {
+  DCHECK(!app_id.empty());
+
+  // Use a prefix, because xdg-desktop-menu requires it.
+  std::string filename(chrome::kBrowserProcessExecutableName);
+  filename.append("-").append(app_id).append("-").append(
+      profile_path.BaseName().value());
+  base::i18n::ReplaceIllegalCharactersInPath(&filename, '_');
+  // Spaces in filenames break xdg-desktop-menu
+  // (see https://bugs.freedesktop.org/show_bug.cgi?id=66605).
+  base::ReplaceChars(filename, " ", "_", &filename);
+  return base::FilePath(filename.append(".desktop"));
+}
+
+void DeleteShortcutOnDesktop(const base::FilePath& shortcut_filename) {
+}
+
+void DeleteShortcutInApplicationsMenu(
+    const base::FilePath& shortcut_filename,
+    const base::FilePath& directory_filename) {
+}
+
+bool CreateDesktopShortcut(
+    const web_app::ShortcutInfo& shortcut_info,
+    const web_app::ShortcutLocations& creation_locations) {
+  return false;
+}
+
+web_app::ShortcutLocations GetExistingShortcutLocations(
+    base::Environment* env,
+    const base::FilePath& profile_path,
+    const std::string& extension_id) {
+  base::FilePath desktop_path;
+  // If Get returns false, just leave desktop_path empty.
+  base::PathService::Get(base::DIR_USER_DESKTOP, &desktop_path);
+  return GetExistingShortcutLocations(env, profile_path, extension_id,
+                                      desktop_path);
+}
+
+web_app::ShortcutLocations GetExistingShortcutLocations(
+    base::Environment* env,
+    const base::FilePath& profile_path,
+    const std::string& extension_id,
+    const base::FilePath& desktop_path) {
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+
+  web_app::ShortcutLocations locations;
+  return locations;
+}
+
+void DeleteDesktopShortcuts(const base::FilePath& profile_path,
+                            const std::string& extension_id) {
+}
+
+void DeleteAllDesktopShortcuts(const base::FilePath& profile_path) {
+}
+
+namespace internals {
+
+bool CreatePlatformShortcuts(const base::FilePath& web_app_path,
+                             const ShortcutLocations& creation_locations,
+                             ShortcutCreationReason /*creation_reason*/,
+                             const ShortcutInfo& shortcut_info) {
+  return false;
+}
+
+void DeletePlatformShortcuts(const base::FilePath& web_app_path,
+                             const ShortcutInfo& shortcut_info) {
+}
+
+void UpdatePlatformShortcuts(const base::FilePath& web_app_path,
+                             const base::string16& /*old_app_title*/,
+                             const ShortcutInfo& shortcut_info) {
+}
+
+void DeleteAllShortcutsForProfile(const base::FilePath& profile_path) {
+}
+
+}  // namespace internals
+
+}  // namespace web_app
--- /dev/null
+++ b/chrome/browser/web_applications/components/web_app_shortcut_android.h
@@ -0,0 +1,62 @@
+// Copyright 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_WEB_APPLICATIONS_COMPONENTS_WEB_APP_SHORTCUT_ANDROID_H_
+#define CHROME_BROWSER_WEB_APPLICATIONS_COMPONENTS_WEB_APP_SHORTCUT_ANDROID_H_
+
+#include <string>
+
+namespace base {
+class FilePath;
+class Environment;
+}  // namespace base
+
+namespace web_app {
+
+struct ShortcutInfo;
+struct ShortcutLocations;
+
+// Create shortcuts on the desktop or in the application menu (as specified by
+// |shortcut_info|), for the web page or extension in |shortcut_info|.
+// For extensions, duplicate shortcuts are avoided, so if a requested shortcut
+// already exists it is deleted first.
+bool CreateDesktopShortcut(const ShortcutInfo& shortcut_info,
+                           const ShortcutLocations& creation_locations);
+
+// Returns filename for .desktop file based on |profile_path| and
+// |app_id|, sanitized for security.
+base::FilePath GetAppShortcutFilename(const base::FilePath& profile_path,
+                                      const std::string& app_id);
+
+// Returns the set of locations in which shortcuts are installed for the
+// extension with |extension_id| in |profile_path|.
+// This searches the file system for .desktop files in appropriate locations. A
+// shortcut with NoDisplay=true causes hidden to become true, instead of
+// creating at APP_MENU_LOCATIONS_SUBDIR_CHROMEAPPS.
+web_app::ShortcutLocations GetExistingShortcutLocations(
+    base::Environment* env,
+    const base::FilePath& profile_path,
+    const std::string& extension_id);
+
+// Version of GetExistingShortcutLocations which takes an explicit path
+// to the user's desktop directory. Useful for testing.
+// If |desktop_path| is empty, the desktop is not searched.
+web_app::ShortcutLocations GetExistingShortcutLocations(
+    base::Environment* env,
+    const base::FilePath& profile_path,
+    const std::string& extension_id,
+    const base::FilePath& desktop_path);
+
+// Delete any desktop shortcuts on desktop or in the application menu that have
+// been added for the extension with |extension_id| in |profile_path|.
+void DeleteDesktopShortcuts(const base::FilePath& profile_path,
+                            const std::string& extension_id);
+
+// Delete any desktop shortcuts on desktop or in the application menu that have
+// for the profile in |profile_path|.
+void DeleteAllDesktopShortcuts(const base::FilePath& profile_path);
+
+}  // namespace web_app
+
+#endif  // CHROME_BROWSER_WEB_APPLICATIONS_COMPONENTS_WEB_APP_SHORTCUT_ANDROID_H_
--- /dev/null
+++ b/ui/base/dragdrop/os_exchange_data_provider_android.cc
@@ -0,0 +1,220 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/dragdrop/os_exchange_data_provider_android.h"
+
+#include "base/logging.h"
+#include "base/memory/ptr_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "net/base/filename_util.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
+#include "ui/base/dragdrop/file_info/file_info.h"
+
+namespace ui {
+
+OSExchangeDataProviderAndroid::OSExchangeDataProviderAndroid()
+    : formats_(0) {
+}
+
+OSExchangeDataProviderAndroid::~OSExchangeDataProviderAndroid() = default;
+
+std::unique_ptr<OSExchangeData::Provider>
+OSExchangeDataProviderAndroid::Clone() const {
+  OSExchangeDataProviderAndroid* ret = new OSExchangeDataProviderAndroid();
+  ret->formats_ = formats_;
+  ret->string_ = string_;
+  ret->url_ = url_;
+  ret->title_ = title_;
+  ret->filenames_ = filenames_;
+  ret->pickle_data_ = pickle_data_;
+  // We skip copying the drag images.
+  ret->html_ = html_;
+  ret->base_url_ = base_url_;
+
+  return base::WrapUnique<OSExchangeData::Provider>(ret);
+}
+
+void OSExchangeDataProviderAndroid::MarkOriginatedFromRenderer() {
+  // TODO(dcheng): Currently unneeded because ChromeOS Android correctly separates
+  // URL and filename metadata, and does not implement the DownloadURL protocol.
+}
+
+bool OSExchangeDataProviderAndroid::DidOriginateFromRenderer() const {
+  return false;
+}
+
+void OSExchangeDataProviderAndroid::SetString(const base::string16& data) {
+  if (HasString())
+    return;
+
+  string_ = data;
+  formats_ |= OSExchangeData::STRING;
+}
+
+void OSExchangeDataProviderAndroid::SetURL(const GURL& url,
+                                        const base::string16& title) {
+  url_ = url;
+  title_ = title;
+  formats_ |= OSExchangeData::URL;
+
+  SetString(base::UTF8ToUTF16(url.spec()));
+}
+
+void OSExchangeDataProviderAndroid::SetFilename(const base::FilePath& path) {
+  filenames_.clear();
+  filenames_.push_back(FileInfo(path, base::FilePath()));
+  formats_ |= OSExchangeData::FILE_NAME;
+}
+
+void OSExchangeDataProviderAndroid::SetFilenames(
+    const std::vector<FileInfo>& filenames) {
+  filenames_ = filenames;
+  formats_ |= OSExchangeData::FILE_NAME;
+}
+
+void OSExchangeDataProviderAndroid::SetPickledData(
+    const ClipboardFormatType& format,
+    const base::Pickle& data) {
+  pickle_data_[format] = data;
+  formats_ |= OSExchangeData::PICKLED_DATA;
+}
+
+bool OSExchangeDataProviderAndroid::GetString(base::string16* data) const {
+  if ((formats_ & OSExchangeData::STRING) == 0)
+    return false;
+  *data = string_;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetURLAndTitle(
+    OSExchangeData::FilenameToURLPolicy policy,
+    GURL* url,
+    base::string16* title) const {
+  if ((formats_ & OSExchangeData::URL) == 0) {
+    title->clear();
+    return GetPlainTextURL(url) ||
+           (policy == OSExchangeData::CONVERT_FILENAMES && GetFileURL(url));
+  }
+
+  if (!url_.is_valid())
+    return false;
+
+  *url = url_;
+  *title = title_;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetFilename(base::FilePath* path) const {
+  if ((formats_ & OSExchangeData::FILE_NAME) == 0)
+    return false;
+  DCHECK(!filenames_.empty());
+  *path = filenames_[0].path;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetFilenames(
+    std::vector<FileInfo>* filenames) const {
+  if ((formats_ & OSExchangeData::FILE_NAME) == 0)
+    return false;
+  *filenames = filenames_;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetPickledData(
+    const ClipboardFormatType& format,
+    base::Pickle* data) const {
+  PickleData::const_iterator i = pickle_data_.find(format);
+  if (i == pickle_data_.end())
+    return false;
+
+  *data = i->second;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::HasString() const {
+  return (formats_ & OSExchangeData::STRING) != 0;
+}
+
+bool OSExchangeDataProviderAndroid::HasURL(
+    OSExchangeData::FilenameToURLPolicy policy) const {
+  if ((formats_ & OSExchangeData::URL) != 0) {
+    return true;
+  }
+  // No URL, see if we have plain text that can be parsed as a URL.
+  return GetPlainTextURL(NULL) ||
+         (policy == OSExchangeData::CONVERT_FILENAMES && GetFileURL(nullptr));
+}
+
+bool OSExchangeDataProviderAndroid::HasFile() const {
+  return (formats_ & OSExchangeData::FILE_NAME) != 0;
+}
+
+bool OSExchangeDataProviderAndroid::HasCustomFormat(
+    const ClipboardFormatType& format) const {
+  return pickle_data_.find(format) != pickle_data_.end();
+}
+
+void OSExchangeDataProviderAndroid::SetHtml(const base::string16& html,
+                                         const GURL& base_url) {
+  formats_ |= OSExchangeData::HTML;
+  html_ = html;
+  base_url_ = base_url;
+}
+
+bool OSExchangeDataProviderAndroid::GetHtml(base::string16* html,
+                                         GURL* base_url) const {
+  if ((formats_ & OSExchangeData::HTML) == 0)
+    return false;
+  *html = html_;
+  *base_url = base_url_;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::HasHtml() const {
+  return ((formats_ & OSExchangeData::HTML) != 0);
+}
+
+void OSExchangeDataProviderAndroid::SetDragImage(
+    const gfx::ImageSkia& image,
+    const gfx::Vector2d& cursor_offset) {
+  drag_image_ = image;
+  drag_image_offset_ = cursor_offset;
+}
+
+gfx::ImageSkia OSExchangeDataProviderAndroid::GetDragImage() const {
+  return drag_image_;
+}
+
+gfx::Vector2d OSExchangeDataProviderAndroid::GetDragImageOffset() const {
+  return drag_image_offset_;
+}
+
+bool OSExchangeDataProviderAndroid::GetFileURL(GURL* url) const {
+  base::FilePath file_path;
+  if (!GetFilename(&file_path))
+    return false;
+
+  GURL test_url = net::FilePathToFileURL(file_path);
+  if (!test_url.is_valid())
+    return false;
+
+  if (url)
+    *url = test_url;
+  return true;
+}
+
+bool OSExchangeDataProviderAndroid::GetPlainTextURL(GURL* url) const {
+  if ((formats_ & OSExchangeData::STRING) == 0)
+    return false;
+
+  GURL test_url(string_);
+  if (!test_url.is_valid())
+    return false;
+
+  if (url)
+    *url = test_url;
+  return true;
+}
+
+}  // namespace ui
--- /dev/null
+++ b/ui/base/dragdrop/os_exchange_data_provider_android.h
@@ -0,0 +1,101 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_ANDROID_H_
+#define UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_ANDROID_H_
+
+#include <map>
+
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "base/pickle.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/gfx/geometry/vector2d.h"
+#include "ui/gfx/image/image_skia.h"
+#include "url/gurl.h"
+
+namespace ui {
+
+struct ClipboardFormatType;
+
+// OSExchangeData::Provider implementation for Android on linux.
+class UI_BASE_EXPORT OSExchangeDataProviderAndroid
+    : public OSExchangeData::Provider {
+ public:
+  OSExchangeDataProviderAndroid();
+  ~OSExchangeDataProviderAndroid() override;
+
+  // Overridden from OSExchangeData::Provider:
+  std::unique_ptr<Provider> Clone() const override;
+  void MarkOriginatedFromRenderer() override;
+  bool DidOriginateFromRenderer() const override;
+  void SetString(const base::string16& data) override;
+  void SetURL(const GURL& url, const base::string16& title) override;
+  void SetFilename(const base::FilePath& path) override;
+  void SetFilenames(const std::vector<FileInfo>& filenames) override;
+  void SetPickledData(const ClipboardFormatType& format,
+                      const base::Pickle& data) override;
+  bool GetString(base::string16* data) const override;
+  bool GetURLAndTitle(OSExchangeData::FilenameToURLPolicy policy,
+                      GURL* url,
+                      base::string16* title) const override;
+  bool GetFilename(base::FilePath* path) const override;
+  bool GetFilenames(std::vector<FileInfo>* filenames) const override;
+  bool GetPickledData(const ClipboardFormatType& format,
+                      base::Pickle* data) const override;
+  bool HasString() const override;
+  bool HasURL(OSExchangeData::FilenameToURLPolicy policy) const override;
+  bool HasFile() const override;
+  bool HasCustomFormat(const ClipboardFormatType& format) const override;
+
+  void SetHtml(const base::string16& html, const GURL& base_url) override;
+  bool GetHtml(base::string16* html, GURL* base_url) const override;
+  bool HasHtml() const override;
+  void SetDragImage(const gfx::ImageSkia& image,
+                    const gfx::Vector2d& cursor_offset) override;
+  gfx::ImageSkia GetDragImage() const override;
+  gfx::Vector2d GetDragImageOffset() const override;
+
+ private:
+  typedef std::map<ClipboardFormatType, base::Pickle> PickleData;
+
+  // Returns true if |formats_| contains a file format and the file name can be
+  // parsed as a URL.
+  bool GetFileURL(GURL* url) const;
+
+  // Returns true if |formats_| contains a string format and the string can be
+  // parsed as a URL.
+  bool GetPlainTextURL(GURL* url) const;
+
+  // Actual formats that have been set. See comment above |known_formats_|
+  // for details.
+  int formats_;
+
+  // String contents.
+  base::string16 string_;
+
+  // URL contents.
+  GURL url_;
+  base::string16 title_;
+
+  // File name.
+  std::vector<FileInfo> filenames_;
+
+  // PICKLED_DATA contents.
+  PickleData pickle_data_;
+
+  // Drag image and offset data.
+  gfx::ImageSkia drag_image_;
+  gfx::Vector2d drag_image_offset_;
+
+  // For HTML format
+  base::string16 html_;
+  GURL base_url_;
+
+  DISALLOW_COPY_AND_ASSIGN(OSExchangeDataProviderAndroid);
+};
+
+}  // namespace ui
+
+#endif  // UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_ANDROID_H_
--- a/ui/base/dragdrop/os_exchange_data_provider_factory.cc
+++ b/ui/base/dragdrop/os_exchange_data_provider_factory.cc
@@ -16,6 +16,8 @@
 #include "ui/base/dragdrop/os_exchange_data_provider_win.h"
 #endif
 
+#include "ui/base/dragdrop/os_exchange_data_provider_android.h"
+
 namespace ui {
 
 //static
@@ -33,6 +35,8 @@ OSExchangeDataProviderFactory::CreatePro
   // TODO(crbug.com/980371): Implement OSExchangeDataProvider for Fuchsia.
   NOTIMPLEMENTED();
   return nullptr;
+#elif defined(OS_ANDROID)
+  return std::make_unique<OSExchangeDataProviderAndroid>();
 #else
 #error "Unknown operating system"
 #endif
--- a/chrome/browser/media/router/media_router_base.cc
+++ b/chrome/browser/media/router/media_router_base.cc
@@ -88,12 +88,10 @@ MediaRouterBase::GetFlingingController(c
   return nullptr;
 }
 
-#if !defined(OS_ANDROID)
 void MediaRouterBase::GetMediaController(
     const MediaRoute::Id& route_id,
     mojo::PendingReceiver<mojom::MediaController> controller,
     mojo::PendingRemote<mojom::MediaStatusObserver> observer) {}
-#endif  // !defined(OS_ANDROID)
 
 MediaRouterBase::MediaRouterBase() : initialized_(false) {}
 
--- a/chrome/browser/media/router/media_router_base.h
+++ b/chrome/browser/media/router/media_router_base.h
@@ -19,11 +19,9 @@
 #include "chrome/common/media_router/media_route.h"
 #include "third_party/blink/public/mojom/presentation/presentation.mojom.h"
 
-#if !defined(OS_ANDROID)
 #include "chrome/common/media_router/mojom/media_controller.mojom.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
-#endif  // !defined(OS_ANDROID)
 
 namespace media_router {
 
@@ -42,12 +40,10 @@ class MediaRouterBase : public MediaRout
   std::vector<MediaRoute> GetCurrentRoutes() const override;
   std::unique_ptr<media::FlingingController> GetFlingingController(
       const MediaRoute::Id& route_id) override;
-#if !defined(OS_ANDROID)
   void GetMediaController(
       const MediaRoute::Id& route_id,
       mojo::PendingReceiver<mojom::MediaController> controller,
       mojo::PendingRemote<mojom::MediaStatusObserver> observer) override;
-#endif  // !defined(OS_ANDROID)
   void RegisterRemotingSource(SessionID tab_id,
                               CastRemotingConnector* remoting_source) override;
   void UnregisterRemotingSource(SessionID tab_id) override;
--- a/chrome/browser/media/router/media_router.h
+++ b/chrome/browser/media/router/media_router.h
@@ -27,11 +27,9 @@
 #include "media/base/flinging_controller.h"
 #include "third_party/blink/public/mojom/presentation/presentation.mojom.h"
 
-#if !defined(OS_ANDROID)
 #include "chrome/common/media_router/mojom/media_controller.mojom.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
-#endif  // !defined(OS_ANDROID)
 
 namespace content {
 class WebContents;
@@ -198,7 +196,6 @@ class MediaRouter : public KeyedService
   virtual std::unique_ptr<media::FlingingController> GetFlingingController(
       const MediaRoute::Id& route_id) = 0;
 
-#if !defined(OS_ANDROID)
   // Binds |controller| for sending media commands to a route. The controller
   // will notify |observer| whenever there is a change to the status of the
   // media. It may invalidate bindings from previous calls to this method.
@@ -206,7 +203,6 @@ class MediaRouter : public KeyedService
       const MediaRoute::Id& route_id,
       mojo::PendingReceiver<mojom::MediaController> controller,
       mojo::PendingRemote<mojom::MediaStatusObserver> observer) = 0;
-#endif  // !defined(OS_ANDROID)
 
   // Registers/Unregisters a CastRemotingConnector with the |tab_id|. For a
   // given |tab_id|, only one CastRemotingConnector can be registered. The
--- a/chrome/browser/media/router/media_router_feature.cc
+++ b/chrome/browser/media/router/media_router_feature.cc
@@ -23,13 +23,10 @@
 #include "components/user_prefs/user_prefs.h"
 #endif  // defined(OS_ANDROID) || BUILDFLAG(ENABLE_EXTENSIONS)
 
-#if !defined(OS_ANDROID)
 #include "components/prefs/pref_registry_simple.h"
-#endif
 
 namespace media_router {
 
-#if !defined(OS_ANDROID)
 // Controls if browser side DialMediaRouteProvider is enabled.
 const base::Feature kDialMediaRouteProvider{"DialMediaRouteProvider",
                                             base::FEATURE_ENABLED_BY_DEFAULT};
@@ -37,7 +34,6 @@ const base::Feature kCastMediaRouteProvi
                                             base::FEATURE_DISABLED_BY_DEFAULT};
 const base::Feature kCastAllowAllIPsFeature{"CastAllowAllIPs",
                                             base::FEATURE_DISABLED_BY_DEFAULT};
-#endif
 
 #if defined(OS_ANDROID) || BUILDFLAG(ENABLE_EXTENSIONS)
 namespace {
@@ -67,7 +63,6 @@ bool MediaRouterEnabled(content::Browser
 #endif  // defined(OS_ANDROID) || BUILDFLAG(ENABLE_EXTENSIONS)
 }
 
-#if !defined(OS_ANDROID)
 void RegisterLocalStatePrefs(PrefRegistrySimple* registry) {
   registry->RegisterBooleanPref(prefs::kMediaRouterCastAllowAllIPs, false,
                                 PrefRegistry::PUBLIC);
@@ -121,6 +116,4 @@ bool ShouldUseMirroringService() {
          base::FeatureList::IsEnabled(kCastMediaRouteProvider);
 }
 
-#endif  // !defined(OS_ANDROID)
-
 }  // namespace media_router
--- a/chrome/browser/media/router/media_router_feature.h
+++ b/chrome/browser/media/router/media_router_feature.h
@@ -19,8 +19,6 @@ namespace media_router {
 // Returns true if Media Router is enabled for |context|.
 bool MediaRouterEnabled(content::BrowserContext* context);
 
-#if !defined(OS_ANDROID)
-
 // TODO(crbug.com/1028753): Remove default-enabled kDialMediaRouteProvider after
 // tests stop disabling it.
 extern const base::Feature kDialMediaRouteProvider;
@@ -66,8 +64,6 @@ bool CastMediaRouteProviderEnabled();
 // Returns true if Mirroring Service should be used for mirroring.
 bool ShouldUseMirroringService();
 
-#endif  // !defined(OS_ANDROID)
-
 }  // namespace media_router
 
 #endif  // CHROME_BROWSER_MEDIA_ROUTER_MEDIA_ROUTER_FEATURE_H_
--- a/chrome/browser/ui/browser.h
+++ b/chrome/browser/ui/browser.h
@@ -55,10 +55,6 @@
 #include "ui/gfx/geometry/rect.h"
 #include "ui/shell_dialogs/select_file_dialog.h"
 
-#if defined(OS_ANDROID)
-#error This file should only be included on desktop.
-#endif
-
 class BackgroundContents;
 class BrowserContentSettingBubbleModelDelegate;
 class BrowserInstantController;
--- a/chrome/browser/ui/signin_view_controller.h
+++ b/chrome/browser/ui/signin_view_controller.h
@@ -13,10 +13,6 @@
 #include "components/signin/public/base/signin_buildflags.h"
 #include "url/gurl.h"
 
-#if defined(OS_ANDROID)
-#error This file should only be included on desktop.
-#endif
-
 class Browser;
 class SigninViewControllerDelegate;
 struct CoreAccountId;
--- a/chrome/browser/ui/tabs/tab_strip_model.h
+++ b/chrome/browser/ui/tabs/tab_strip_model.h
@@ -31,10 +31,6 @@
 #include "ui/base/models/list_selection_model.h"
 #include "ui/base/page_transition_types.h"
 
-#if defined(OS_ANDROID)
-#error This file should only be included on desktop.
-#endif
-
 class Profile;
 class TabGroupModel;
 class TabStripModelDelegate;
--- a/extensions/browser/guest_view/web_view/web_view_guest.cc
+++ b/extensions/browser/guest_view/web_view/web_view_guest.cc
@@ -145,6 +145,7 @@ static std::string TerminationStatusToSt
     case base::TERMINATION_STATUS_PROCESS_WAS_KILLED_BY_OOM:
       return "oom killed";
 #endif
+    case base::TERMINATION_STATUS_OOM_PROTECTED:
     case base::TERMINATION_STATUS_OOM:
       return "oom";
     case base::TERMINATION_STATUS_PROCESS_WAS_KILLED:
--- a/extensions/browser/api/device_permissions_prompt.cc
+++ b/extensions/browser/api/device_permissions_prompt.cc
@@ -221,8 +221,6 @@ class HidDevicePermissionsPrompt : publi
     const auto& binder = GetHidManagerBinderOverride();
     if (binder)
       binder.Run(std::move(receiver));
-    else
-      content::GetDeviceService().BindHidManager(std::move(receiver));
 
     hid_manager_->GetDevicesAndSetClient(
         receiver_.BindNewEndpointAndPassRemote(),
--- a/extensions/browser/api/hid/hid_device_manager.cc
+++ b/extensions/browser/api/hid/hid_device_manager.cc
@@ -296,8 +296,6 @@ void HidDeviceManager::LazyInitialize()
     const auto& binder = GetHidManagerBinderOverride();
     if (binder)
       binder.Run(std::move(receiver));
-    else
-      content::GetDeviceService().BindHidManager(std::move(receiver));
   }
   // Enumerate HID devices and set client.
   std::vector<device::mojom::HidDeviceInfoPtr> empty_devices;
--- a/ui/base/dragdrop/os_exchange_data.h
+++ b/ui/base/dragdrop/os_exchange_data.h
@@ -63,7 +63,7 @@ class UI_BASE_EXPORT OSExchangeData {
 #if defined(OS_WIN)
     FILE_CONTENTS  = 1 << 4,
 #endif
-#if defined(USE_AURA)
+#if defined(USE_AURA) || defined(OS_ANDROID)
     HTML           = 1 << 5,
 #endif
   };
@@ -138,13 +138,13 @@ class UI_BASE_EXPORT OSExchangeData {
     virtual void SetDownloadFileInfo(DownloadFileInfo* download) = 0;
 #endif
 
-#if defined(USE_AURA)
+#if defined(USE_AURA) || defined(OS_ANDROID)
     virtual void SetHtml(const base::string16& html, const GURL& base_url) = 0;
     virtual bool GetHtml(base::string16* html, GURL* base_url) const = 0;
     virtual bool HasHtml() const = 0;
 #endif
 
-#if defined(USE_AURA) || defined(OS_MACOSX)
+#if defined(USE_AURA) || defined(OS_MACOSX) || defined(OS_ANDROID)
     virtual void SetDragImage(const gfx::ImageSkia& image,
                               const gfx::Vector2d& cursor_offset) = 0;
     virtual gfx::ImageSkia GetDragImage() const = 0;
@@ -269,7 +269,7 @@ class UI_BASE_EXPORT OSExchangeData {
   void SetDownloadFileInfo(DownloadFileInfo* download);
 #endif
 
-#if defined(USE_AURA)
+#if defined(USE_AURA) || defined(OS_ANDROID)
   // Adds a snippet of HTML.  |html| is just raw html but this sets both
   // text/html and CF_HTML.
   void SetHtml(const base::string16& html, const GURL& base_url);
--- a/ui/views/controls/menu/menu_host.cc
+++ b/ui/views/controls/menu/menu_host.cc
@@ -28,7 +28,7 @@ namespace views {
 
 namespace internal {
 
-#if !defined(OS_MACOSX)
+#if !defined(OS_MACOSX) && !defined(OS_ANDROID)
 // This class adds itself as the pre target handler for the |window|
 // passed in. It currently handles touch events and forwards them to the
 // controller. Reason for this approach is views does not get raw touch
@@ -80,7 +80,7 @@ class PreMenuEventDispatchHandler : publ
 #endif  // OS_MACOSX
 
 void TransferGesture(Widget* source, Widget* target) {
-#if defined(OS_MACOSX)
+#if defined(OS_MACOSX) || defined(OS_ANDROID)
   NOTIMPLEMENTED();
 #else   // !defined(OS_MACOSX)
   source->GetGestureRecognizer()->TransferEventsTo(
@@ -138,7 +138,7 @@ void MenuHost::InitMenuHost(Widget* pare
 #endif
   Init(std::move(params));
 
-#if !defined(OS_MACOSX)
+#if !defined(OS_MACOSX) && !defined(OS_ANDROID)
   pre_dispatch_handler_ =
       std::make_unique<internal::PreMenuEventDispatchHandler>(
           menu_controller, submenu_, GetNativeView());
@@ -203,7 +203,7 @@ void MenuHost::DestroyMenuHost() {
   HideMenuHost();
   destroying_ = true;
   static_cast<MenuHostRootView*>(GetRootView())->ClearSubmenu();
-#if !defined(OS_MACOSX)
+#if !defined(OS_MACOSX) && !defined(OS_ANDROID)
   pre_dispatch_handler_.reset();
 #endif
   Close();
--- a/ui/events/event.h
+++ b/ui/events/event.h
@@ -19,6 +19,7 @@
 #include "base/strings/string16.h"
 #include "base/time/time.h"
 #include "build/build_config.h"
+#include "ui/android/window_android.h"
 #include "ui/events/event_constants.h"
 #include "ui/events/gesture_event_details.h"
 #include "ui/events/gestures/gesture_types.h"
--- a/ui/views/controls/menu/menu_controller.h
+++ b/ui/views/controls/menu/menu_controller.h
@@ -18,6 +18,7 @@
 #include "base/memory/weak_ptr.h"
 #include "base/timer/timer.h"
 #include "build/build_config.h"
+#include "ui/android/window_android.h"
 #include "ui/events/event.h"
 #include "ui/events/event_constants.h"
 #include "ui/events/platform/platform_event_dispatcher.h"
--- a/ui/views/controls/menu/menu_host.h
+++ b/ui/views/controls/menu/menu_host.h
@@ -95,7 +95,7 @@ class MenuHost : public Widget, public W
   // If true and capture is lost we don't notify the delegate.
   bool ignore_capture_lost_;
 
-#if !defined(OS_MACOSX)
+#if !defined(OS_MACOSX) && !defined(OS_ANDROID)
   // Handles raw touch events at the moment.
   std::unique_ptr<internal::PreMenuEventDispatchHandler> pre_dispatch_handler_;
 #endif
--- a/ui/android/window_android.h
+++ b/ui/android/window_android.h
@@ -50,6 +50,13 @@ class UI_ANDROID_EXPORT WindowAndroid :
 
   base::android::ScopedJavaLocalRef<jobject> GetJavaObject();
 
+  static void ConvertPointToTarget(const WindowAndroid* source,
+                                   const WindowAndroid* target,
+                                   gfx::PointF* point);
+  static void ConvertPointToTarget(const WindowAndroid* source,
+                                   const WindowAndroid* target,
+                                   gfx::Point* point);
+
   // Compositor callback relay.
   void OnCompositingDidCommit();
 
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -421,7 +421,7 @@
 #include "chrome/browser/chrome_browser_main_posix.h"
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/badging/badge_manager.h"
 #include "chrome/browser/devtools/chrome_devtools_manager_delegate.h"
 #include "chrome/browser/devtools/devtools_window.h"
--- a/chrome/browser/devtools/chrome_devtools_manager_delegate.h
+++ b/chrome/browser/devtools/chrome_devtools_manager_delegate.h
@@ -13,8 +13,6 @@
 #include "base/compiler_specific.h"
 #include "base/macros.h"
 #include "chrome/browser/devtools/device/devtools_device_discovery.h"
-#include "chrome/browser/devtools/protocol/forward.h"
-#include "chrome/browser/devtools/protocol/protocol.h"
 #include "content/public/browser/devtools_agent_host_observer.h"
 #include "content/public/browser/devtools_manager_delegate.h"
 #include "net/base/host_port_pair.h"
--- a/chrome/browser/search/instant_service.h
+++ b/chrome/browser/search/instant_service.h
@@ -33,7 +33,7 @@
 #include "ui/native_theme/native_theme_observer.h"
 #include "url/gurl.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/search/instant_service_factory.h
+++ b/chrome/browser/search/instant_service_factory.h
@@ -10,7 +10,7 @@
 #include "build/build_config.h"
 #include "components/keyed_service/content/browser_context_keyed_service_factory.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/ui/browser_window.h
+++ b/chrome/browser/ui/browser_window.h
@@ -31,7 +31,7 @@
 #include "ui/gfx/native_widget_types.h"
 #include "url/origin.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error This file should only be included on desktop.
 #endif
 
--- a/chrome/browser/extensions/api/messaging/native_messaging_host_manifest.cc
+++ b/chrome/browser/extensions/api/messaging/native_messaging_host_manifest.cc
@@ -136,19 +136,6 @@ bool NativeMessagingHostManifest::Parse(
     allowed_origins_.AddPattern(pattern);
   }
 
-  if (base::FeatureList::IsEnabled(features::kOnConnectNative)) {
-    if (const base::Value* supports_native_initiated_connections =
-            dictionary->FindKey("supports_native_initiated_connections")) {
-      if (!supports_native_initiated_connections->is_bool()) {
-        *error_message =
-            "supports_native_initiated_connections must be a boolean.";
-        return false;
-      }
-      supports_native_initiated_connections_ =
-          supports_native_initiated_connections->GetBool();
-    }
-  }
-
   return true;
 }
 
--- a/chrome/browser/extensions/api/downloads/downloads_api.cc
+++ b/chrome/browser/extensions/api/downloads/downloads_api.cc
@@ -52,6 +52,7 @@
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_list.h"
 #include "chrome/browser/ui/browser_window.h"
+#include "chrome/browser/ui/tabs/tab_strip_model.h"
 #include "chrome/common/extensions/api/downloads.h"
 #include "components/download/public/common/download_interrupt_reasons.h"
 #include "components/download/public/common/download_item.h"
--- a/chrome/browser/profiles/profile.cc
+++ b/chrome/browser/profiles/profile.cc
@@ -38,8 +38,8 @@
 #include "chromeos/constants/chromeos_switches.h"
 #endif
 
-#if !defined(OS_ANDROID)
-#include "chrome/browser/first_run/first_run.h"
+#if defined(OS_ANDROID)
+//#include "chrome/browser/first_run/first_run.h"
 #include "content/public/browser/host_zoom_map.h"
 #endif
 
@@ -128,7 +128,7 @@ TestingProfile* Profile::AsTestingProfil
   return nullptr;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 ChromeZoomLevelPrefs* Profile::GetZoomLevelPrefs() {
   return nullptr;
 }
--- a/chrome/browser/profiles/profile.h
+++ b/chrome/browser/profiles/profile.h
@@ -21,7 +21,7 @@
 #include "services/network/public/mojom/network_context.mojom-forward.h"
 #include "url/gurl.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 class ChromeZoomLevelPrefs;
 #endif
 
@@ -218,7 +218,7 @@ class Profile : public content::BrowserC
   virtual PrefService* GetPrefs() = 0;
   virtual const PrefService* GetPrefs() const = 0;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Retrieves a pointer to the PrefService that manages the default zoom
   // level and the per-host zoom levels for this user profile.
   // TODO(wjmaclean): Remove this when HostZoomMap migrates to StoragePartition.
--- a/chrome/browser/ui/browser_navigator_params.cc
+++ b/chrome/browser/ui/browser_navigator_params.cc
@@ -21,7 +21,7 @@ using content::GlobalRequestID;
 using content::NavigationController;
 using content::WebContents;
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 NavigateParams::NavigateParams(std::unique_ptr<WebContents> contents_to_insert)
     : contents_to_insert(std::move(contents_to_insert)) {}
 #else
--- a/chrome/browser/ui/browser_navigator_params.h
+++ b/chrome/browser/ui/browser_navigator_params.h
@@ -25,7 +25,7 @@
 #include "ui/gfx/geometry/rect.h"
 #include "url/gurl.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/tabs/tab_strip_model.h"
 #include "components/tab_groups/tab_group_id.h"
 #endif
@@ -63,7 +63,7 @@ struct OpenURLParams;
 
 // TODO(thestig): Split or ifdef out more fields that are not used on Android.
 struct NavigateParams {
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
   explicit NavigateParams(
       std::unique_ptr<content::WebContents> contents_to_insert);
 #else
@@ -211,7 +211,7 @@ struct NavigateParams {
   };
   PathBehavior path_behavior = RESPECT;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // [in]  Specifies a Browser object where the navigation could occur or the
   //       tab could be added. Navigate() is not obliged to use this Browser if
   //       it is not compatible with the operation being performed. This can be
--- a/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
+++ b/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
@@ -420,35 +420,7 @@ void SafeBrowsingPrivateEventRouter::OnS
     const std::string& mime_type,
     const std::string& trigger,
     const int64_t content_size) {
-  if (!IsRealtimeReportingEnabled())
     return;
-
-  ReportRealtimeEvent(
-      kKeySensitiveDataEvent,
-      base::BindOnce(
-          [](const std::string& url, const std::string& file_name,
-             const std::string& download_digest_sha256,
-             const std::string& profile_user_name, const std::string& mime_type,
-             const std::string& trigger, const int64_t content_size) {
-            // Create a real-time event dictionary from the arguments and
-            // report it.
-            base::Value event(base::Value::Type::DICTIONARY);
-            event.SetStringKey(kKeyUrl, url);
-            event.SetStringKey(kKeyFileName, file_name);
-            event.SetStringKey(kKeyDownloadDigestSha256,
-                               download_digest_sha256);
-            event.SetStringKey(kKeyProfileUserName, profile_user_name);
-            event.SetStringKey(kKeyContentType, mime_type);
-            // |content_size| can be set to -1 to indicate an unknown size, in
-            // which case the field is not set.
-            if (content_size >= 0)
-              event.SetIntKey(kKeyContentSize, content_size);
-            event.SetStringKey(kKeyTrigger, trigger);
-            event.SetBoolKey(kKeyClickedThrough, true);
-            return event;
-          },
-          url.spec(), file_name, download_digest_sha256, GetProfileUserName(),
-          mime_type, trigger, content_size));
 }
 
 void SafeBrowsingPrivateEventRouter::OnUnscannedFileEvent(
--- a/chrome/common/pref_names.cc
+++ b/chrome/common/pref_names.cc
@@ -2429,7 +2429,7 @@ const char kCustomHandlersEnabled[] = "c
 // by the cloud policy subsystem.
 const char kDevicePolicyRefreshRate[] = "policy.device_refresh_rate";
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // A boolean where true means that the browser has previously attempted to
 // enable autoupdate and failed, so the next out-of-date browser start should
 // not prompt the user to enable autoupdate, it should offer to reinstall Chrome
@@ -2561,7 +2561,7 @@ const char kRecoveryComponentNeedsElevat
 const char kRegisteredSupervisedUserWhitelists[] =
     "supervised_users.whitelists";
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Boolean that indicates whether Chrome enterprise cloud reporting is enabled
 // or not.
 const char kCloudReportingEnabled[] =
--- a/chrome/common/pref_names.h
+++ b/chrome/common/pref_names.h
@@ -814,7 +814,7 @@ extern const char kRelaunchNotificationP
 extern const char kRelaunchHeadsUpPeriod[];
 #endif  // defined(OS_CHROMEOS)
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kAttemptedToEnableAutoupdate[];
 
 extern const char kMediaGalleriesUniqueId[];
@@ -865,7 +865,7 @@ extern const char kRecoveryComponentNeed
 
 extern const char kRegisteredSupervisedUserWhitelists[];
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kCloudReportingEnabled[];
 extern const char kCloudExtensionRequestEnabled[];
 extern const char kCloudExtensionRequestIds[];
--- a/chrome/browser/extensions/api/tabs/windows_event_router.cc
+++ b/chrome/browser/extensions/api/tabs/windows_event_router.cc
@@ -164,8 +164,6 @@ WindowsEventRouter::WindowsEventRouter(P
                  content::NotificationService::AllSources());
 #elif defined(TOOLKIT_VIEWS)
   views::WidgetFocusManager::GetInstance()->AddFocusChangeListener(this);
-#else
-#error Unsupported
 #endif
 
   AppWindowRegistry* registry = AppWindowRegistry::Get(profile_);
--- a/chrome/common/chrome_features.cc
+++ b/chrome/common/chrome_features.cc
@@ -328,7 +328,7 @@ const base::Feature kEnableAmbientAuthen
     "EnableAmbientAuthenticationInGuestSession",
     base::FEATURE_DISABLED_BY_DEFAULT};
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Upload enterprise cloud reporting without the extension.
 const base::Feature kEnterpriseReportingInBrowser{
     "EnterpriseReportingInBrowser", base::FEATURE_DISABLED_BY_DEFAULT};
@@ -521,7 +521,7 @@ const base::Feature kAcknowledgeNtpOverr
 const base::Feature kMixedContentSiteSetting{"MixedContentSiteSetting",
                                              base::FEATURE_ENABLED_BY_DEFAULT};
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 const base::Feature kOnConnectNative{"OnConnectNative",
                                      base::FEATURE_DISABLED_BY_DEFAULT};
 #endif
--- a/chrome/common/chrome_features.h
+++ b/chrome/common/chrome_features.h
@@ -187,7 +187,7 @@ extern const base::Feature kEnableAmbien
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kEnableAmbientAuthenticationInIncognito;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kEnterpriseReportingInBrowser;
 #endif
@@ -327,7 +327,7 @@ extern const base::Feature kAcknowledgeN
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kMixedContentSiteSetting;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES) extern const base::Feature kOnConnectNative;
 #endif
 
--- a/chrome/browser/extensions/api/enterprise_reporting_private/chrome_desktop_report_request_helper.cc
+++ b/chrome/browser/extensions/api/enterprise_reporting_private/chrome_desktop_report_request_helper.cc
@@ -89,12 +89,7 @@ std::string GetProfileId(const Profile*
 // Returns last policy fetch timestamp of machine level user cloud policy if
 // it exists. Otherwise, returns zero.
 int64_t GetMachineLevelUserCloudPolicyFetchTimestamp() {
-  policy::MachineLevelUserCloudPolicyManager* manager =
-      g_browser_process->browser_policy_connector()
-          ->machine_level_user_cloud_policy_manager();
-  if (!manager || !manager->IsClientRegistered())
     return 0;
-  return manager->core()->client()->last_policy_timestamp().ToJavaTime();
 }
 
 void AppendAdditionalBrowserInformation(em::ChromeDesktopReportRequest* request,
--- a/chrome/common/chrome_paths.cc
+++ b/chrome/common/chrome_paths.cc
@@ -545,7 +545,7 @@ bool PathProvider(int key, base::FilePat
 #endif
       break;
 
-#if defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_ANDROID)
     case chrome::DIR_NATIVE_MESSAGING:
 #if defined(OS_MACOSX)
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
--- a/chrome/common/chrome_paths.h
+++ b/chrome/common/chrome_paths.h
@@ -122,7 +122,7 @@ enum {
   DIR_SUPERVISED_USER_INSTALLED_WHITELISTS,  // Directory where sanitized
                                              // supervised user whitelists are
                                              // installed.
-#if defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_ANDROID)
   DIR_NATIVE_MESSAGING,       // System directory where native messaging host
                               // manifest files are stored.
   DIR_USER_NATIVE_MESSAGING,  // Directory with Native Messaging Hosts
--- a/chrome/browser/profiles/profile_window.h
+++ b/chrome/browser/profiles/profile_window.h
@@ -15,9 +15,6 @@
 #include "chrome/browser/ui/profile_chooser_constants.h"
 #include "chrome/browser/ui/startup/startup_types.h"
 
-#if defined(OS_ANDROID)
-#error "Not used on Android"
-#endif
 
 class Profile;
 
--- a/chrome/browser/profiles/profiles_state.cc
+++ b/chrome/browser/profiles/profiles_state.cc
@@ -27,7 +27,7 @@
 #include "content/public/browser/browsing_data_remover.h"
 #include "ui/base/l10n/l10n_util.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/browser.h"
 #endif
 
@@ -81,7 +81,7 @@ void SetLastUsedProfile(const std::strin
   local_state->SetString(prefs::kProfileLastUsed, profile_dir);
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 base::string16 GetAvatarNameForProfile(const base::FilePath& profile_path) {
   if (profile_path == ProfileManager::GetGuestProfilePath()) {
     return l10n_util::GetStringUTF16(IDS_GUEST_PROFILE_NAME);
--- a/chrome/browser/profiles/profiles_state.h
+++ b/chrome/browser/profiles/profiles_state.h
@@ -43,7 +43,7 @@ void RegisterPrefs(PrefRegistrySimple* r
 // System Profile directory, which is an invalid last used profile.
 void SetLastUsedProfile(const std::string& profile_dir);
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Returns the display name of the specified on-the-record profile (or guest),
 // specified by |profile_path|, used in the avatar button or user manager. If
 // |profile_path| is the guest path, it will return IDS_GUEST_PROFILE_NAME. If
--- a/ui/views/controls/webview/unhandled_keyboard_event_handler_default.cc
+++ b/ui/views/controls/webview/unhandled_keyboard_event_handler_default.cc
@@ -13,7 +13,7 @@ namespace views {
 bool UnhandledKeyboardEventHandler::HandleNativeKeyboardEvent(
     gfx::NativeEvent event,
     FocusManager* focus_manager) {
-  return !focus_manager->OnKeyEvent(*(event->AsKeyEvent()));
+  return false;
 }
 
 }  // namespace views
--- /dev/null
+++ b/extensions/browser/api/system_cpu/cpu_info_provider_android.cc
@@ -0,0 +1,77 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "extensions/browser/api/system_cpu/cpu_info_provider.h"
+
+#include <stdint.h>
+
+#include <cstdio>
+#include <sstream>
+
+#include "base/files/file_util.h"
+#include "base/format_macros.h"
+
+namespace extensions {
+
+namespace {
+
+const char kProcStat[] = "/proc/stat";
+
+}  // namespace
+
+bool CpuInfoProvider::QueryCpuTimePerProcessor(
+    std::vector<api::system_cpu::ProcessorInfo>* infos) {
+  DCHECK(infos);
+
+  // WARNING: this method may return incomplete data because some processors may
+  // be brought offline at runtime. /proc/stat does not report statistics of
+  // offline processors. CPU usages of offline processors will be filled with
+  // zeros.
+  //
+  // An example of output of /proc/stat when processor 0 and 3 are online, but
+  // processor 1 and 2 are offline:
+  //
+  //   cpu  145292 20018 83444 1485410 995 44 3578 0 0 0
+  //   cpu0 138060 19947 78350 1479514 570 44 3576 0 0 0
+  //   cpu3 2033 32 1075 1400 52 0 1 0 0 0
+  std::string contents;
+  if (!base::ReadFileToString(base::FilePath(kProcStat), &contents))
+    return false;
+
+  std::istringstream iss(contents);
+  std::string line;
+
+  // Skip the first line because it is just an aggregated number of
+  // all cpuN lines.
+  std::getline(iss, line);
+  while (std::getline(iss, line)) {
+    if (line.compare(0, 3, "cpu") != 0)
+      continue;
+
+    uint64_t user = 0, nice = 0, sys = 0, idle = 0;
+    uint32_t pindex = 0;
+    int vals =
+        sscanf(line.c_str(),
+               "cpu%" PRIu32 " %" PRIu64 " %" PRIu64 " %" PRIu64 " %" PRIu64,
+               &pindex,
+               &user,
+               &nice,
+               &sys,
+               &idle);
+    if (vals != 5 || pindex >= infos->size()) {
+      NOTREACHED();
+      return false;
+    }
+
+    infos->at(pindex).usage.kernel = static_cast<double>(sys);
+    infos->at(pindex).usage.user = static_cast<double>(user + nice);
+    infos->at(pindex).usage.idle = static_cast<double>(idle);
+    infos->at(pindex).usage.total =
+        static_cast<double>(sys + user + nice + idle);
+  }
+
+  return true;
+}
+
+}  // namespace extensions
--- a/chrome/browser/media/webrtc/media_capture_devices_dispatcher.cc
+++ b/chrome/browser/media/webrtc/media_capture_devices_dispatcher.cc
@@ -112,15 +112,6 @@ MediaCaptureDevicesDispatcher::MediaCapt
   media_access_handlers_.push_back(
       std::make_unique<ExtensionMediaAccessHandler>());
 #endif
-  media_access_handlers_.push_back(
-      std::make_unique<DesktopCaptureAccessHandler>());
-#if defined(OS_CHROMEOS)
-  // Wrapper around TabCaptureAccessHandler used in Public Sessions.
-  media_access_handlers_.push_back(
-      std::make_unique<PublicSessionTabCaptureAccessHandler>());
-#else
-  media_access_handlers_.push_back(std::make_unique<TabCaptureAccessHandler>());
-#endif
 #endif
   media_access_handlers_.push_back(
       std::make_unique<PermissionBubbleMediaAccessHandler>());
--- /dev/null
+++ b/chrome/browser/apps/platform_apps/api/music_manager_private/device_id_android.cc
@@ -0,0 +1,188 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/apps/platform_apps/api/music_manager_private/device_id.h"
+
+#include <ifaddrs.h>
+#include <net/if.h>
+#include <stddef.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>  // Must be included before ifaddrs.h.
+
+#include <map>
+
+#include "base/bind.h"
+#include "base/files/file_enumerator.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/stl_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/task/post_task.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "content/public/browser/browser_task_traits.h"
+#include "content/public/browser/browser_thread.h"
+
+namespace chrome_apps {
+namespace api {
+
+namespace {
+
+typedef base::Callback<bool(const void* bytes, size_t size)>
+    IsValidMacAddressCallback;
+
+const char kDiskByUuidDirectoryName[] = "/dev/disk/by-uuid";
+const char* const kDeviceNames[] = {
+    "sda1", "hda1", "dm-0", "xvda1", "sda2", "hda2", "dm-1", "xvda2",
+};
+
+// Map from device name to disk uuid
+typedef std::map<base::FilePath, base::FilePath> DiskEntries;
+
+std::string GetDiskUuid() {
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+
+  DiskEntries disk_uuids;
+  base::FileEnumerator files(base::FilePath(kDiskByUuidDirectoryName),
+                             false,  // Recursive.
+                             base::FileEnumerator::FILES);
+  do {
+    base::FilePath file_path = files.Next();
+    if (file_path.empty())
+      break;
+
+    base::FilePath target_path;
+    if (!base::ReadSymbolicLink(file_path, &target_path))
+      continue;
+
+    base::FilePath device_name = target_path.BaseName();
+    base::FilePath disk_uuid = file_path.BaseName();
+    disk_uuids[device_name] = disk_uuid;
+  } while (true);
+
+  // Look for first device name matching an entry of |kDeviceNames|.
+  std::string result;
+  for (size_t i = 0; i < base::size(kDeviceNames); i++) {
+    DiskEntries::iterator it = disk_uuids.find(base::FilePath(kDeviceNames[i]));
+    if (it != disk_uuids.end()) {
+      DVLOG(1) << "Returning uuid: \"" << it->second.value()
+               << "\" for device \"" << it->first.value() << "\"";
+      result = it->second.value();
+      break;
+    }
+  }
+
+  // Log failure (at most once) for diagnostic purposes.
+  static bool error_logged = false;
+  if (result.empty() && !error_logged) {
+    error_logged = true;
+    LOG(ERROR) << "Could not find appropriate disk uuid.";
+    for (DiskEntries::iterator it = disk_uuids.begin(); it != disk_uuids.end();
+         ++it) {
+      LOG(ERROR) << "  DeviceID=" << it->first.value()
+                 << ", uuid=" << it->second.value();
+    }
+  }
+
+  return result;
+}
+
+class MacAddressProcessor {
+ public:
+  explicit MacAddressProcessor(
+      const IsValidMacAddressCallback& is_valid_mac_address)
+      : is_valid_mac_address_(is_valid_mac_address) {}
+
+  bool ProcessInterface(struct ifaddrs* ifaddr,
+                        const char* const prefixes[],
+                        size_t prefixes_count) {
+    const int MAC_LENGTH = 6;
+    struct ifreq ifinfo;
+
+    memset(&ifinfo, 0, sizeof(ifinfo));
+    strncpy(ifinfo.ifr_name, ifaddr->ifa_name, sizeof(ifinfo.ifr_name) - 1);
+
+    int sd = socket(AF_INET, SOCK_DGRAM, 0);
+    int result = ioctl(sd, SIOCGIFHWADDR, &ifinfo);
+    close(sd);
+
+    if (result != 0)
+      return true;
+
+    const char* mac_address =
+        static_cast<const char*>(ifinfo.ifr_hwaddr.sa_data);
+    if (!is_valid_mac_address_.Run(mac_address, MAC_LENGTH))
+      return true;
+
+    if (!IsValidPrefix(ifinfo.ifr_name, prefixes, prefixes_count))
+      return true;
+
+    // Got one!
+    found_mac_address_ =
+        base::ToLowerASCII(base::HexEncode(mac_address, MAC_LENGTH));
+    return false;
+  }
+
+  std::string mac_address() const { return found_mac_address_; }
+
+ private:
+  bool IsValidPrefix(const char* name,
+                     const char* const prefixes[],
+                     size_t prefixes_count) {
+    for (size_t i = 0; i < prefixes_count; i++) {
+      if (strncmp(prefixes[i], name, strlen(prefixes[i])) == 0)
+        return true;
+    }
+    return false;
+  }
+
+  const IsValidMacAddressCallback& is_valid_mac_address_;
+  std::string found_mac_address_;
+};
+
+std::string GetMacAddress(
+    const IsValidMacAddressCallback& is_valid_mac_address) {
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+
+  int rv = -1;
+  if (rv < 0) {
+    PLOG(ERROR) << "getifaddrs failed " << rv;
+    return "";
+  }
+
+  MacAddressProcessor processor(is_valid_mac_address);
+  return processor.mac_address();
+}
+
+void GetRawDeviceIdImpl(const IsValidMacAddressCallback& is_valid_mac_address,
+                        const DeviceId::IdCallback& callback) {
+  std::string disk_id = GetDiskUuid();
+  std::string mac_address = GetMacAddress(is_valid_mac_address);
+
+  std::string raw_device_id;
+  if (!mac_address.empty() && !disk_id.empty()) {
+    raw_device_id = mac_address + disk_id;
+  }
+
+  base::PostTask(FROM_HERE, {content::BrowserThread::UI},
+                 base::BindOnce(callback, raw_device_id));
+}
+
+}  // namespace
+
+// static
+void DeviceId::GetRawDeviceId(const IdCallback& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  base::PostTask(
+      FROM_HERE, traits(),
+      base::BindOnce(&GetRawDeviceIdImpl,
+                     base::Bind(&DeviceId::IsValidMacAddress), callback));
+}
+
+}  // namespace api
+}  // namespace chrome_apps
--- a/chrome/browser/ui/browser_commands.cc
+++ b/chrome/browser/ui/browser_commands.cc
@@ -76,6 +76,7 @@
 #include "components/prefs/pref_service.h"
 #include "components/sessions/core/live_tab_context.h"
 #include "components/sessions/core/tab_restore_service.h"
+#include "components/signin/public/base/signin_metrics.h"
 #include "components/translate/core/browser/language_state.h"
 #include "components/version_info/version_info.h"
 #include "components/web_modal/web_contents_modal_dialog_manager.h"
